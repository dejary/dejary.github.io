<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Manjaro踩坑记录</title>
    <url>/2019/01/23/Linux/Linux-Manjaro%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>对比ubuntu、CentOS，我更加喜欢Manjaro系统，这里主要记录下自己使用过程中的一些问题和经验。</p>
<a id="more"></a> 

<h1 id="Win10-Manjaro双系统安装"><a href="#Win10-Manjaro双系统安装" class="headerlink" title="Win10 Manjaro双系统安装"></a>Win10 Manjaro双系统安装</h1><p>建议最好还是用UEFI+GRUB的引导方案，我的电脑是双硬盘，两个系统分别安装在2个硬盘上。硬盘分区是，只要存在一个EFI分区就行，EFI分区专门用来放引导索引的，另外一个硬盘全市GPT主分区。<br>安装时，必须先安装WIN10系统，否则Manjaro会启动不起来，我猜测是WIN10会破坏掉引导分区。安装完WIN10后，可以再制作一个老毛桃启动盘，进入启动盘的系统后可以开一下EFI分区里面的内容。</p>
<p>安装WIN10系统没什么好讲的。安装完成后，首先我们要关闭这个功能：进入 BIOS 找到 Secure Boot，选择 disabled，这样就关闭了。当然，有些人进入 BIOS 会发现 Secure Boot 这个选项是灰色的（比如我的就是），这时你需要先给你的 BIOS 设一个密码，然后就能关 Secure Boot 了。</p>
<p>下载rufus，用来制作manjaro启动盘，制作时请选择dd模式，manjaro必须要dd模式才可以安装。启动安装时主要是在选择挂在点的时候，直接将/boot/efi 挂在到已存在的EFI分区即可，不要选择格式化/boot/efi所挂在的点，这样安装过程中不会破坏掉原有的内容。安装完成后，两个系统的引导文件都存在与EFI分区中。</p>
<p>重启之后，不出意外的话，你会直接进入 Windows 10，不要担心，这时 Linux 已经安装成功了，我们只需要将引导文件替换一下。在WIN10上进入管理员命令行。方法：win + x，再按 a<br>输入 <code>bcdedit /set ‘{bootmgr}’ path \EFI\Manjaro\grubx64.efi</code>。提示操作成功的话，就完成了。</p>
<p>这部分参考这个文章，描写得很清楚：<a href="https://www.jianshu.com/p/5007e555ec12" target="_blank" rel="noopener">https://www.jianshu.com/p/5007e555ec12</a></p>
<h2 id="设置软件源"><a href="#设置软件源" class="headerlink" title="设置软件源"></a>设置软件源</h2><p>使用命令sudo pacman-mirrors -i -c China -m rank, 然后选择速度最快的即可。</p>
<h2 id="更新系统"><a href="#更新系统" class="headerlink" title="更新系统"></a>更新系统</h2><p>一条命令<code>sudo pacman -Syyu</code> 即可更新系统到最新版，更新系统过程若是提示 /usr/lib/xfce4/thunar-archive-plugin/engrampa.tap 冲突。可以通过如下的方法来处理：</p>
<ul>
<li>pacman -Qo /usr/lib/xfce4/thunar-archive-plugin/engrampa.tap 查询到/usr/lib/xfce4/thunar-archive-plugin/engrampa.tap 由 engrampa-thunar-plugin 1.0-2 所拥有然后搜索此软件包engrampa-thunar-plugin 卸载后 就正常了</li>
<li>或者直接删除/usr/lib/xfce4/thunar-archive-plugin/engrampa.tap</li>
</ul>
<p>然后用命令行运行 <code>pacman -S archlinuxcn-keyring</code></p>
<h1 id="必要软件安装"><a href="#必要软件安装" class="headerlink" title="必要软件安装"></a>必要软件安装</h1><h2 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo pacman -S vim </span><br><span class="line">bash &lt;(curl -fsSL https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;liuchengxu&#x2F;space-vim&#x2F;master&#x2F;install.sh)</span><br></pre></td></tr></table></figure>

<h2 id="中文输入法"><a href="#中文输入法" class="headerlink" title="中文输入法"></a>中文输入法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo pacman -S fcitx-im # 全部安装</span><br><span class="line">sudo pacman -S fcitx-configtool # 图形化配置工具</span><br><span class="line">sudo pacman -S fcitx-sogoupinyin 或者 fcitx-googlepinyin</span><br></pre></td></tr></table></figure>
<p>vim ~/.xprofile 打开或者创建xprofile文件，添加如下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export GTK_IM_MODULE&#x3D;fcitx</span><br><span class="line">export QT_IM_MODULE&#x3D;fcitx</span><br><span class="line">export XMODIFIERS&#x3D;&quot;@im&#x3D;fcitx&quot;</span><br></pre></td></tr></table></figure>
<p>重启设备或者在终端中输入fcitx启动服务之后，在系统的右下角右一个键盘图标，右击这个图标，打开配置管理工具，需要将搜狗拼音添加到输入方法中。</p>
<h2 id="zsh"><a href="#zsh" class="headerlink" title="zsh"></a>zsh</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo pacman -S zsh</span><br><span class="line">	sh -c &quot;$(curl -fsSL https:&#x2F;&#x2F;raw.github.com&#x2F;robbyrussell&#x2F;oh-my-zsh&#x2F;master&#x2F;tools&#x2F;install.sh)&quot;</span><br><span class="line">	chsh -s &#x2F;bin&#x2F;zsh</span><br></pre></td></tr></table></figure>

<h2 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h2><p>使用命令<code>uname -r</code> 查看内核的版本，比如输出了4.14.69-1-MANJARO，那么你的内核版本为414<br>使用命令来安装virtualbox及它的插件，命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo pacman -Sy virtualbox linux414-virtualbox-host-modules virtualbox-ext-oracle</span><br></pre></td></tr></table></figure>
<p>使用如下命令<code>sudo gpasswd -a $USER vboxusers # $USER为当前用户</code>添加当前用户到vboxusers组<br>然后重新启动系统或执行<code>sudo modprobe vboxdrv</code></p>
<p>参考：</p>
<h2 id="其它软件安装"><a href="#其它软件安装" class="headerlink" title="其它软件安装"></a>其它软件安装</h2><p>在PACMAN管理工具的属性中可以开启AUR，通过界面来管理软件更加直观，剩下的软件基本上都可以通过软件中心来查找、安装和卸载。其它必须安装的软件有：</p>
<ul>
<li>git</li>
<li>cmake</li>
<li>uget</li>
<li>aria2</li>
<li>filezilla</li>
<li>google-chrome</li>
<li>netease-cloud-music</li>
<li>peek 屏幕录像工具，小巧玲珑，可保存录像为gif动图和兼容于html5的webm视频；</li>
<li>fish 一个不错的shell</li>
</ul>
<h2 id="解决-Windows-和-Manjaro-双系统时间差8小时的问题"><a href="#解决-Windows-和-Manjaro-双系统时间差8小时的问题" class="headerlink" title="解决 Windows 和 Manjaro 双系统时间差8小时的问题"></a>解决 Windows 和 Manjaro 双系统时间差8小时的问题</h2><p>电脑系统中有两个时间：</p>
<ol>
<li>硬件时间：保存在主板中，信息比较少没时区、夏令时的概念</li>
<li>系统时间：又系统维护，独立于硬件时间，拥有时区、夏令时等信息</li>
</ol>
<p>系统时间又因为系统的不同使用了两种时间管理办法：</p>
<ol>
<li>localtime：本地时间，目前只有 Windows 在使用。</li>
<li>UTC：是一种世界标准时间，Linux 这类类 UNIX 多数会使用，UTC 加减时区之后才是本地时间。</li>
</ol>
<p>然后问题就来了,Windows 认为硬件时间就是本地时间，所以会直接把主板中的时间拿来当做当前的时间。设置或同步时间后也会把“正确”的时间写入主板。而 Linux 认为硬件时间是 UTC 标准时间，Linux 时间同步后会把“正确”的时间 -8 之后作为标准 UTC 标准时间写入主板。</p>
<p>具体操作是：在 Settings -&gt; Manjaro Settings Manager -&gt; Time and Date 中即可设置，建议起用”Set time and date automatically”, 根据情况来决定是否勾选 “Hardware clock in local time zone”</p>
<h1 id="pacman介绍"><a href="#pacman介绍" class="headerlink" title="pacman介绍"></a>pacman介绍</h1><p>Pacman 是一个软件包管理器，作为ArchLinux发行版的一部分。简单来说，就是和apt-get之于Ubuntu一样，pacman就是Arch的apt-get。<br>Pacman的配置文件位于/etc/pacman.conf</p>
<ol>
<li>安装或者升级单个软件包，或者一列软件包（包含依赖包），使用如下命令：pacman -S package_name1 package_name2</li>
<li>有时候在不同的软件仓库中，一个软件包有多个版本（比如extra和testing）。你可以选择一个来安装： pacman -S extra/package_name</li>
<li>删除单个软件包，保留其全部已经安装的依赖关系： pacman -R package_name</li>
<li>删除指定软件包，及其所有没有被其他已安装软件包使用的依赖关系：pacman -Rs package_name</li>
<li>缺省的，pacman会备份被删除程序的配置文件，将它们加上*.pacsave扩展名。如果你在删除软件包时要同时删除相应的配置文件（这种行为在基于Debian的系统中称为清除purging），你可是使用命令：pacman -Rn package_name</li>
<li>真正删除一个软件包、它的配置文件以及所有不再需要的依赖的命令如下：pacman -Rsn package_name</li>
<li>一个指令来升级系统中所有已安装的包。升级的时间取决于你的系统有多新： pacman -Su</li>
<li>将升级系统和同步仓库数据合成为一条指令：pacman -Syu</li>
<li>包数据库中查询软件包，查询位置包含了包的名字和描述：pacman -Ss package</li>
<li>要查询已安装的软件包：pacman -Qs package</li>
<li>要获取已安装软件包所包含文件的列表：pacman -Ql package</li>
<li>通过查询数据库获知目前你的文件系统中某个文件是属于哪个软件包： pacman -Qo /path/to/a/file</li>
<li>安装一个’本地’包（不从源里）:pacman -U /path/to/package/package_name-version.pkg.tar.gz</li>
<li>安装一个’远程’包（不从源里）：pacman -U <a href="http://url/package_name-version.pkg.tar.gz" target="_blank" rel="noopener">http://url/package_name-version.pkg.tar.gz</a></li>
<li>清理当前未被安装软件包的缓存(/var/cache/pacman/pkg):pacman -Sc</li>
<li>重新安装你系统中所有的软件包（仓库中已有的）：pacman -S $(pacman -Qq | grep -v “$(pacman -Qmq)”)</li>
<li>获取本地软件包和它们大小的一个已排序清单列表：LANG=C pacman -Qi | sed -n ‘/^Name[^:]<em>: (.</em>)/{s//1 /;x};/^Installed[^:]<em>: (.</em>)/{s//1/;H;x;s/n//;p}’ | sort -nk2</li>
</ol>
<p>附注：<br>ArchLinux的版本库里面包括：<br>　　core-核心软件包<br>　　extra-其他常用软件<br>　　community-社区软件包，譬如Mysql等。<br>　　testing-正在测试阶段，还没有正式加入源的软件包。通常软件版本比较新，但是不是非常稳定<br>　　release-已经发布的软件包<br>　　unstable-非正式的软件包，可能包括以前版本的软件或者测试软件</p>
<p>　　因为Pacman的软件都是从源里面更新，因此在/etc/pacman.d里面配置这些软件源的地址。在/etc/pacman.d目录里面分别有上面几种软件类型对应的文件名，可以自己手工配置这些软件源的地址。</p>
<p>参考资料：<br><a href="https://linux.cn/article-9925-1.html" target="_blank" rel="noopener">https://linux.cn/article-9925-1.html</a></p>
<h1 id="其它问题解决"><a href="#其它问题解决" class="headerlink" title="其它问题解决"></a>其它问题解决</h1><h2 id="科学上网"><a href="#科学上网" class="headerlink" title="科学上网"></a>科学上网</h2><p>本来计算使用shadowsocks-qt5 加 chrome插件SwitchyOmega。 但是无论怎么设置都不行。最后，我是在另外一台笔记本电脑上启用了局域网代理，这样才通过了设置成功得使得chrome可以科学上网。</p>
<p>命令行下的代理设置按照如下的方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;rofl0r&#x2F;proxychains-ng.git </span><br><span class="line">cd proxychains-ng </span><br><span class="line">.&#x2F;configure #配置</span><br><span class="line">sudo make &amp;&amp; sudo make install #编译安装</span><br><span class="line">cp .&#x2F;src&#x2F;proxychains.conf &#x2F;etc&#x2F;proxychains.conf #提取配置文件</span><br><span class="line">cd .. &amp;&amp; rm -rf proxychains-ng #删除安装文件</span><br><span class="line">vim &#x2F;etc&#x2F;proxychains.conf 更改最后一行的地址和端口</span><br></pre></td></tr></table></figure>
<p>在需要使用代理的命令前加上 proxychain4，比如：<br>proxychains4 wget <a href="http://xxx.com/xxx.zip" target="_blank" rel="noopener">http://xxx.com/xxx.zip</a></p>
<p>GIT的代理设置（暂不设置）<br>利用shadowsocks的socks5代理，配置好后明显加速。用下面两条命令配置好后，保持shadowsocks客户端开启就行了。<br>git config –global http.proxy ‘socks5://127.0.0.1:1080’<br>git config –global https.proxy ‘socks5://127.0.0.1:1080’ </p>
<h2 id="vmware-tools-共享文件夹的问题"><a href="#vmware-tools-共享文件夹的问题" class="headerlink" title="vmware tools 共享文件夹的问题"></a>vmware tools 共享文件夹的问题</h2><p>如果时通过虚拟机来安装manjaro，很有可能重启后，就无法自动的显示共享文件夹了。需要手动的运行启动才行。不管手动还是自动，都需要先在虚拟机的配置中添加需要共享的文件夹。进入虚拟机操作系统后，通过 <code>vmware-hgfsclient</code> 命令查看已经配置的共享目录信息。</p>
<p>使用如下的命令来挂载共享目录，可以将以下的命令写入到一个脚本文件中，比如hgfs.sh，每次开机后手动执行一次，也不是很麻烦的事。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir &lt;shared folders root directory&gt;</span><br><span class="line">sudo vmhgfs-fuse -o allow_other -o auto_unmount .host:&#x2F;&lt;shared_folder&gt; &lt;shared folders root directory&gt;</span><br></pre></td></tr></table></figure>

<h2 id="ncurses5-compat-libs"><a href="#ncurses5-compat-libs" class="headerlink" title="ncurses5-compat-libs"></a>ncurses5-compat-libs</h2><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="https://wiki.manjaro.org/index.php?title=Main_Page" target="_blank" rel="noopener">wiki</a></li>
<li><a href="https://medium.com/@ribomo42/install-official-vmware-tools-on-arch-linux-15afd5b848ed" target="_blank" rel="noopener">archlinux vmware tools</a></li>
<li><a href="https://wiki.manjaro.org/index.php?title=Virtualbox" target="_blank" rel="noopener">virtualbox</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Manjaro</tag>
      </tags>
  </entry>
  <entry>
    <title>理解sed命令</title>
    <url>/2019/01/24/Linux/Linux-%E7%90%86%E8%A7%A3sed%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>sed是一种流编辑器，它是文本处理中非常中的工具，能够完美的配合正则表达式使用，功能不同凡响。处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”（pattern space），接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件末尾。文件内容并没有 改变，除非你使用重定向存储输出。Sed主要用来自动编辑一个或多个文件；简化对文件的反复操作；编写转换程序等。</p>
<h2 id="命令的格式"><a href="#命令的格式" class="headerlink" title="命令的格式"></a>命令的格式</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sed [options] &#39;command&#39; file(s)</span><br><span class="line">sed [options] -f scriptfile file(s)</span><br></pre></td></tr></table></figure>

<p>第一种是将对行的操作命令放在命令中，这种比较常见。第二种是将对行的命令独立放在一个文本文件中。 选项部分常用有：</p>
<ul>
<li><code>-n</code>，用来控制是打印全部的行，还是只打印受影响的行。</li>
<li><code>-i</code>，默认的sed处理的文件都无法影响到文件本身。使用这个选项可以编辑文件本身，等同于将命令的输出再重定向到本文件。文件的内容为去掉-i之后命令的输出内容。</li>
</ul>
<h2 id="命令部分的写法"><a href="#命令部分的写法" class="headerlink" title="命令部分的写法"></a>命令部分的写法</h2><p>sed命令最难理解的就是’’之间的内容，也就是对行的操作命令。操作命令的基本格式就是，操作行范围+对行上的操作，具体表示如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[n1,[n2]]function</span><br></pre></td></tr></table></figure>
<p>范围表示如下：</p>
<ul>
<li>n1和n2部分指定本条命令需要处理的哪些行，n1表示开始行，n2表示结束行。</li>
<li>如果没有n1,n2的话就表示处理全部行。</li>
<li>也可以只有n1，用来特质某行。</li>
<li>可以直接通过数字指定。比如2,5就是第2行到第5行。</li>
<li>用$可以表示最后行，比如2,$d就表示删除第2到最后一行</li>
<li>范围不一定时连续的一些行，也可以时满足条件的一些行，比如<code>sed &#39;/^test/&#39;d file</code> 删除所有test开始行</li>
<li>也可以用正则表达式来表示满足条件的行，比如 <code>sed -n &#39;5,/^test/p&#39; file</code></li>
</ul>
<p>常用的操作有如下：</p>
<ul>
<li>a 插入内容，在当前行下面插入文本，后面跟要插入的内容</li>
<li>i 插入内容，在当前行上面插入文本</li>
<li>c 替换，把选定的行改为新的文本</li>
<li>d 删除</li>
<li>p 打印</li>
<li>s 替换，使用正则表达式替换行内的特定字符。</li>
</ul>
<p>不同的参数后面还可以跟不同的具体内容，用来表示操作的参数。比如，a新增行可以跟需要新增的内容，d删除就没啥跟的。</p>
<h3 id="s替换命令"><a href="#s替换命令" class="headerlink" title="s替换命令"></a>s替换命令</h3><p>s命令用正则表达式来替换行内的内容，基本格式<code>s/s1/s2/s3</code>常规的用法就不说了，这里记录下一些强大的用法。</p>
<ul>
<li>(..) 匹配子串，保存匹配的字符，如<code>s/\(love\)able/\1rs，loveable被替换成lovers</code></li>
<li>&amp; 保存搜索字符用来替换其他字符，如<code>s/love/**&amp;**/，love这成**love**</code></li>
<li>使用后缀 /g 标记会替换每一行中的所有匹配，当需要从第N处匹配开始替换时，可以使用 /Ng。</li>
</ul>
<p>&amp; 主要用在命令的s2部分，利用s1匹配到的内容。在s1匹配到时就调用s2的部分进行替换。比如：正则表达式 <code>\w\+</code> 匹配每一个单词，使用 [&amp;] 替换它，&amp; 对应于之前所匹配到的单词：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo this is a test line | sed &#39;s&#x2F;\w\+&#x2F;[&amp;]&#x2F;g&#39;</span><br><span class="line">[this] [is] [a] [test] [line]</span><br></pre></td></tr></table></figure>
<p>所有以192.168.0.1开头的行都会被替换成它自已加localhost：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sed &#39;s&#x2F;^192.168.0.1&#x2F;&amp;localhost&#x2F;&#39; file</span><br><span class="line">192.168.0.1localhost</span><br></pre></td></tr></table></figure>

<p>子串匹配标记<code>\1</code></p>
<p>s1部分需要用括号来表示一个子串，括号内所匹配的内容就是一个子串的内容，子串有编号。在s2部分使用<code>\1,\2</code>等来引用子串的内容。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo this is digit 7 in a number | sed &#39;s&#x2F;digit \([0-9]\)&#x2F;\1&#x2F;&#39;</span><br><span class="line">this is 7 in a number</span><br></pre></td></tr></table></figure>
<p>命令中 digit 7，被替换成了 7。样式匹配到的子串是 7，<code>\(..\)</code> 用于匹配子串，对于匹配到的第一个子串就标记为 <code>\1</code>，依此类推匹配到的第二个结果就是 <code>\2</code>。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.cnblogs.com/ctaixw/p/5860221.html" target="_blank" rel="noopener">1. 一篇很详细的使用示例</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>sed</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux常用命令记录</title>
    <url>/2019/01/24/Linux/Linux-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h2 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h2><h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><h2 id="egrep"><a href="#egrep" class="headerlink" title="egrep"></a>egrep</h2><h2 id="rsync"><a href="#rsync" class="headerlink" title="rsync"></a>rsync</h2><h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><h2 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h2><h2 id="uniq"><a href="#uniq" class="headerlink" title="uniq"></a>uniq</h2><h2 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h2><h2 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h2><h2 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h2><h2 id="sz和lz"><a href="#sz和lz" class="headerlink" title="sz和lz"></a>sz和lz</h2><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>awk</tag>
        <tag>grep</tag>
        <tag>find</tag>
        <tag>egrep</tag>
        <tag>rsync</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux系统开机启动理解</title>
    <url>/2019/06/02/Linux/Linux-%E7%B3%BB%E7%BB%9F%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8/</url>
    <content><![CDATA[<p>系统的开机启动研究只从init进程接管了之后说起，开机运行到init后，通过/etc/inittab 确定了系统的runlevel和将要运行的脚本。系统层的启动，一切从这里起源，以下的说明可以通过跟踪相关文件来得知，这里仅做一些总结性的说明。</p>
<h1 id="最常见的方式"><a href="#最常见的方式" class="headerlink" title="最常见的方式"></a>最常见的方式</h1><ol>
<li>通常需要开机启动的脚本统一放置在/etc/init.d 或者 /etc/rc.d/init.d 目录下。</li>
<li>在/etc或者/etc/rc.d/目录下有 rc5.d/rc4.d…等目录，里面放置了在各种runlevel下要执行的脚本，而且文件名是特殊格式的命名，可以用来控制执行顺序。目录下的脚本都是软链接，指向init.d目录下的真正的脚本。</li>
<li>以上的机制通常也定义了rc.local 为系统启动后最后的执行文件。</li>
</ol>
<p>如果要关闭某些程序的开机启动，只需要将rc5.d/S…文件改为 rc.5/K…  ，由S开头改为K开头的就行。</p>
<h1 id="某些嵌入式系统可能采用的方式"><a href="#某些嵌入式系统可能采用的方式" class="headerlink" title="某些嵌入式系统可能采用的方式"></a>某些嵌入式系统可能采用的方式</h1><ol>
<li>第一步还是差不多，将开机时可能需要用到的脚本统一放置在/etc/init.d 或者 /etc/rc.d/init.d 目录下。</li>
<li>没有通过不同的目录来区分不同的runlevel，而且可能将所有开机启动的脚本全部列在某个配置文件中，顺序也是在配置文件中定义好的。</li>
<li>rc.local 并不一定是系统启动阶段最后执行的脚本文件，这个需要特别注意，只将通用的一些命令放在这里，具体在某个正在研发的设备的非通用外设的命令很可能无法生效。</li>
</ol>
<h1 id="定义自己的开机顺序"><a href="#定义自己的开机顺序" class="headerlink" title="定义自己的开机顺序"></a>定义自己的开机顺序</h1><p>要想在开机启动过程中启动某个程序，大体上有3种方法。。</p>
<ol>
<li>直接在某个文件中启动，比如rc.local 里启动。</li>
<li>直接将脚本文件放在某个目录下 </li>
<li>根据某种工具的要求，按照格式要求新增启动脚本，然后将此脚本利用工具注册到系统中。</li>
</ol>
<p>这3种方法本质上还是利用了上述的启动过程原理，方法3只不过是借助了工具来管理而已，本质上与其它方法没有区别。选择某个方式的时候，可以按照如下的需求来做决定：如果启动脚本很简单，只有简单的几行命令，可以使用方法1；如果启动脚本很复杂，需要监测环境，进行复杂的设置时，可以使用方法2； 如果启动脚本对应的服务需要在启动后被人为的停止、再启动话，最好采用方法3，支持简单的命令来启动、停止、重新启动等需求。</p>
<p>涉及管理开机启动服务的工具有：</p>
<ol>
<li>chkconfig</li>
<li>crontab</li>
<li>rcconf</li>
<li>update-rc.d</li>
<li>systemctl</li>
<li>sysv-rc-conf</li>
</ol>
<p>上面是总结了系统在开机启动过程涉及的一些知识，这个启动过程是在用户登录之前。那么用户登录的过程中，调用脚本的一些情况是怎么样的顺序呢？这里也总结下：</p>
<ol>
<li><code>/etc/profile</code> 脚本文件被执行，通常该脚本会去遍历/etc/profile.d目录下的*.sh文件并执行。这个是所有用户都有效的配置。</li>
<li><code>~/.bash_profile、~/.bash_login、~/.profile</code> 这3个文件是按照顺序查找的，一旦找到某一个，后面的就忽略了。针对当前用户的配置放在这里，只在用户第一次登录的时候执行。</li>
<li><code>~/.bashrc</code>，前面的步骤都是在需要用户输入用户名密码等录时启用，登录之后，用户再次打开shell，并不会执行前面的过程。每次打开shell都会运行的脚本放在这里，这里的配置不会被继承。</li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>向终端输出带颜色内容</title>
    <url>/2020/05/04/Linux/%E5%90%91%E7%BB%88%E7%AB%AF%E8%BE%93%E5%87%BA%E5%B8%A6%E9%A2%9C%E8%89%B2%E5%86%85%E5%AE%B9/</url>
    <content><![CDATA[<p>终端能输出不同的颜色，本质上还是终端内置了识别带颜色命令的字符串。在shell中，如果使用echo来输出内容，默认是不带颜色，这是因为终端在处理默认echo的输出时，不认为里面有需要转义处理，里面的内容原样输出。通过<code>echo -e</code>打开转义功能，就可以先终端输出带颜色的内容了，其实除了带颜色的内容，还可以通过转义字符来输出其它内容，比如<code>\t</code>表示tab，<code>\n</code>表示换行等。可以更加灵活的控制输出内容。</p>
<h2 id="颜色控制核心格式"><a href="#颜色控制核心格式" class="headerlink" title="颜色控制核心格式"></a>颜色控制核心格式</h2><p>颜色相关的转义核心格式如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;\033[31mXXXXXXXXXXXXXXXXXX\033[0m&quot;</span><br></pre></td></tr></table></figure>

<p>XXX表示其它正常的内容。其中<code>\033[</code>表示后面是表示关于终端的处理，而不属于内容的一部分。其后面可以跟的内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">33[0m   关闭所有属性</span><br><span class="line">33[1m   设置高亮度</span><br><span class="line">33[4m   下划线</span><br><span class="line">33[5m   闪烁</span><br><span class="line">33[7m   反显</span><br><span class="line">33[8m   消隐</span><br><span class="line">33[30m  至 33[37m 设置前景色</span><br><span class="line">33[40m  至 33[47m 设置背景色</span><br><span class="line">33[nA   光标上移n行 </span><br><span class="line">33[nB   光标下移n行</span><br><span class="line">33[nC   光标右移n行</span><br><span class="line">33[nD   光标左移n行</span><br><span class="line">33[y;xH 设置光标位置</span><br><span class="line">33[2J   清屏</span><br><span class="line">33[K    清除从光标到行尾的内容</span><br><span class="line">33[s    保存光标位置 </span><br><span class="line">33[u    恢复光标位置</span><br><span class="line">33[?25l 隐藏光标</span><br><span class="line">33[?25h 显示光标</span><br></pre></td></tr></table></figure>
<p>其中30m-37m 用来设置前景色，也就是文字的颜色。40m-47m用来设置背景色。</p>
<p>具体颜色表示是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">30:黑</span><br><span class="line">31:红 </span><br><span class="line">32:绿</span><br><span class="line">33:黄</span><br><span class="line">34:蓝色</span><br><span class="line">35:紫色</span><br><span class="line">36:深绿 </span><br><span class="line">37:白色</span><br></pre></td></tr></table></figure>
<p>背景色在相应的颜色上加10即可，具体颜色不用记，真要用时测试下就知道了。</p>
<pre><code>以上的格式控制是可以多个同时叠加的，以达到对终端输出地复杂控制 。</code></pre><h2 id="利用printf命令输出"><a href="#利用printf命令输出" class="headerlink" title="利用printf命令输出"></a>利用printf命令输出</h2><p>前面只是描述了用终端处理接收到的特殊字符的原理，在shell里通常可以用echo -e命令来输出，同样也可以用printf命令来输出。比如，如下的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">printf &quot;[%10s]:    PID-&gt;%-5s     CPU-&gt;%-4s      MEM-&gt;%-7s     STAT-&gt;%-3s \</span><br><span class="line">		    	[\033[32m%7s\033[0m]\n&quot; &quot;$1&quot; &quot;$PID&quot; &quot;$CPU&quot; &quot;$MEM&quot;  &quot;$STAT&quot; &quot;Running&quot;</span><br></pre></td></tr></table></figure>
<p>可以看的出来，只要在字符串里写入相关的格式字符串即可。</p>
<p>printf命令的用法跟C语言的函数很像，可以作为SHELL脚本里比Shell更加灵活的控制格式化输出。上述代码中，%s表示输出字符串，5表示字符串占用5位，不足5位默认右对齐，使用-表示字符串不足5位的使用左对齐。同样的，我们可以控制输出浮点格式的数据，可以指定精度和位数。</p>
<h2 id="C语言中的输出"><a href="#C语言中的输出" class="headerlink" title="C语言中的输出"></a>C语言中的输出</h2><p>C语言的printf函数可以向标准输出打印内容，其打印的内容同样在终端上显示，因此也同样的受终端显示规则的影响。使用上述各式的字符串，可以用来输出颜色。甚至其它语言都可以利用这个原理来控制输出的颜色。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux守护进程理解</title>
    <url>/2019/06/02/Linux/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="守护进程的概念"><a href="#守护进程的概念" class="headerlink" title="守护进程的概念"></a>守护进程的概念</h2><p>守护进程，有一种是业务上的叫法，通常指专门用来检测其它进程运行状态的程序，以方便在其它进程异常时自动重新启动。另外一种就是指是一种运行在后台的特殊进程，它独立于控制终端并且周期性的执行某种任务或等待处理某些发生的事件，其目的跟业务概念上的守护进程完全不一样。</p>
<p>Linux系统的程序大体是可以分为两种，一种是在终端里运行的，需要时敲入命令运行起来，关掉终端也就终止了进程；另外一种是，在后台运行，使用特殊的命令来启动，也可以根据配置来周期性的启动。</p>
<p>在Linux上，守护进程主要指在后台运行的，没有控制终端与之相连的进程。它独立于控制终端，周期性地执行某种任务。Linux的大多数服务器就是用守护进程的方式实现的。如web服务器进程http等。守护进程在后台运行，类似于Windows中的系统服务。</p>
<h2 id="进程组"><a href="#进程组" class="headerlink" title="进程组"></a>进程组</h2><p>每个进程都属于一个进程组，进程组中可以包含一个或多个进程。进程组中有一个组长进程（第一个进程），组长的进程 ID 是进程组 ID(PGID)。</p>
<ul>
<li>当父进程，创建子进程的时候，默认子进程与父进程属于同一进程组</li>
<li>组长进程可以创建一个进程组，创建该进程组中的进程，然后终止。只要进程组中有一个进程存在，进程组就存在，与组长进程是否终止无关</li>
<li>进程组生存期：进程组创建到最后一个进程离开(终止或转移到另一个进程组)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取当前进程的进程组ID</span><br><span class="line">pid_t getpgrp(void);  &#x2F;&#x2F; 总是返回调用者的进程组ID</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获取指定进程的进程组ID，如果pid &#x3D; 0，那么该函数作用和getpgrp一样</span><br><span class="line">pid_t getpgid(pid_t pid);  &#x2F;&#x2F; 成功：0；失败：-1，设置errno</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; setpgid函数：改变进程默认所属的进程组。通常可用来加入一个现有的进程组或创建一个新进程组。</span><br><span class="line">&#x2F;*</span><br><span class="line">** 将参数1对应的进程，加入参数2对应的进程组中。</span><br><span class="line">** 成功：0；失败：-1，设置errno</span><br><span class="line">**&#x2F;</span><br><span class="line">int setpgid(pid_t pid, pid_t pgid);</span><br></pre></td></tr></table></figure>

<p><strong>注意如下两点：</strong></p>
<ol>
<li>如改变子进程为新的组，应在fork后，在exec前。</li>
<li>权级问题。非root进程只能改变自己创建的子进程，或有权限操作的进程</li>
</ol>
<h2 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h2><p>多个进程组构成一个会话，建立会话的进程是会话的领导进程，即会话首进程，该进程 ID 为会话的 SID。</p>
<p>会话中的每个进程组称为一个作业。会话可以有一个进程组作为会话的前台作业，其它进程组作为后台作业。</p>
<p>一个会话可以有一个控制终端，当控制终端有输入和输出时都会传递给前台进程组，比如Ctrl + Z。会话的意义在于能将多个作业通过一个终端控制，一个作为前台操作，其它后台运行。</p>
<p>创建会话注意事项：</p>
<ul>
<li>调用进程不能是<strong>进程组组长<a href="硬性规定">^1</a></strong> ，该进程变成新会话首进程<a href="会话是由多个进程组组成，自然调用进程是新会话的首进程">^2</a> (session header)</li>
<li>该进程成为一个新进程组的组长进程 。</li>
<li>需有root权限(ubuntu不需要)</li>
<li>新会话丢弃原有的控制终端，该会话没有控制终端<a href="终端同一时候只能属于某一个会话，新的会话在创建时自然是没有终端的，后面可以给他关联终端">^3</a>。</li>
<li>若调用进程是组长进程，则出错返回</li>
<li>建立新会话时，先调用fork，父进程终止，子进程调用setsid</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; getsid函数：获取进程所属的会话ID，pid为0表示查看当前进程session ID</span><br><span class="line">&#x2F;&#x2F;成功：返回调用进程的会话ID；失败：-1，设置errno</span><br><span class="line">pid_t getsid(pid_t pid);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; setsid函数：创建一个会话，并以自己的ID设置进程组ID，同时也是新会话的ID</span><br><span class="line">pid_t setsid(void); &#x2F;&#x2F;成功：返回调用进程的会话ID；失败：-1，设置errno</span><br></pre></td></tr></table></figure>

<p style="text-align: center">进程组是一组相关进程的集合，会话是一组相关进程组的集合</p>

<p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://i.loli.net/2020/06/01/4oO2cIupKiZYxj6.png" alt="linux_daemon_01.png"></p>
<p>打开bash时，就是创建了一个会话。在bash中运行的程序，可以是前台进程，也可以是后台进程（加&amp;），bash关联了一个终端，可以接受输入输出并发送给前台进程。</p>
<h1 id="创建守护进程的步骤"><a href="#创建守护进程的步骤" class="headerlink" title="创建守护进程的步骤"></a>创建守护进程的步骤</h1><p>普通进程都有关联一个控制终端、会话、进程组。而守护进程都不一样，因此要采用特殊的处理步骤来达到要求。</p>
<h2 id="1-让程序在后台执"><a href="#1-让程序在后台执" class="headerlink" title="1. 让程序在后台执"></a>1. 让程序在后台执</h2><p>方法是调用fork（）产生一个子进程，然后使父进程exit（）退出。这么做的原因有以下两点：</p>
<ul>
<li>如果守护进程是通过 Shell 启动，父进程退出，Shell 就会认为任务执行完毕，之后的所有工作都在子进程中完成，而用户在Shell终端里则可以执行其他命令，从而在形式上做到了与控制终端的脱离，在后台工作。这时子进程由 init 收养。</li>
<li>子进程继承父进程的进程组 ID，保证了子进程不是进程组组长，因为下面将调用setsid()，它要求必须不是进程组长。</li>
</ul>
<h2 id="2-调用setsid（）创建一个新对话期"><a href="#2-调用setsid（）创建一个新对话期" class="headerlink" title="2. 调用setsid（）创建一个新对话期"></a>2. 调用setsid（）创建一个新对话期</h2><p>在调用了 fork() 函数后，子进程全盘拷贝了父进程的会话期、进程组、控制终端等，虽然父进程退出了，但会话期、进程组、控制终端等并没有改变。这还不是真正意义上的独立开来，而 setsid()函数，使子进程完全独立出来，脱离其它进程的控制。</p>
<h2 id="3-再次-fork-一个子进程，父进程exit-退出"><a href="#3-再次-fork-一个子进程，父进程exit-退出" class="headerlink" title="3. 再次 fork() 一个子进程，父进程exit()退出"></a>3. 再次 fork() 一个子进程，父进程exit()退出</h2><p>经过以上步骤，进程已经成为一个无终端的会话组长（会话首进程），但是它可以重新申请打开一个终端。为了避免这种情况发生，可以通过使进程不再是会话组长来实现 。只要再一次通过fork（）创建新的子进程，使调用fork的进程退出。这样就禁止了关联控制终端的能力。</p>
<h2 id="4-关闭不再需要的文件描述符"><a href="#4-关闭不再需要的文件描述符" class="headerlink" title="4. 关闭不再需要的文件描述符"></a>4. 关闭不再需要的文件描述符</h2><p>用fork函数新建的子进程会从父进程那里继承一些已经打开了的文件。这些被打开的文件可能永远不会被守护进程读写，但它们一样消耗系统资源，而且可能导致所在的文件系统无法卸下。其实在上面的第二步之后，守护进程已经与所属的控制终端失去了联系。</p>
<p>因此从终端输入的字符不可能到达守护进程，守护进程中用常规方法（如printf）输出的字符也不可能在终端上显示出来。所以，文件描述符为0、1和2 的3个文件（常说的输入、输出和报错）已经失去了存在的价值，也应被关闭。（关闭失去价值的输入、输出、报错等对应的文件描述符）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (i&#x3D;0; i &lt; MAXFILE; i++)</span><br><span class="line">	close(i); &#x2F;&#x2F; 全部关闭</span><br></pre></td></tr></table></figure>

<p>首先获得最高文件描述符值，然后用一个循环程序，关闭0到最高文件描述符值的所有文件描述符</p>
<h2 id="5-将当前目录更改为根目录"><a href="#5-将当前目录更改为根目录" class="headerlink" title="5. 将当前目录更改为根目录"></a>5. 将当前目录更改为根目录</h2><p>这一步也是必要的步骤。使用fork创建的子进程继承了父进程的当前工作目录。由于在进程运行中，当前目录所在的文件系统（如“/mnt/dev”）是不能卸载的，这对以后的使用会造成诸多的麻烦（比如系统由于某种原因要进入单用户模式）。因此，通常的做法是让”/“作为守护进程的当前工作目录，这样就可以避免上述的问题，当然，如有特殊需要，也可以把当前工作目录换成其他的路径，如/tmp。改变工作目录的常见函数是chdir。(避免原父进程当前目录带来的一些麻烦)。</p>
<h2 id="6-在子进程中调用umask-重设文件权限掩码为0"><a href="#6-在子进程中调用umask-重设文件权限掩码为0" class="headerlink" title="6. 在子进程中调用umask()重设文件权限掩码为0"></a>6. 在子进程中调用umask()重设文件权限掩码为0</h2><p>文件权限掩码是指屏蔽掉文件权限中的对应位。比如，有个文件权限掩码是050，它就屏蔽了文件组拥有者的可读与可执行权限（就是说可读可执行权限均变为7）。<br>由于使用fork函数新建的子进程继承了父进程的文件权限掩码，这就给该子进程使用文件带来了诸多的麻烦。因此把文件权限掩码重设为0即清除掩码（权限为777），这样可以大大增强该守护进程的灵活性。通常的使用方法为umask(0)。(相当于把权限开放)</p>
<h2 id="7-守护进程退出处理"><a href="#7-守护进程退出处理" class="headerlink" title="7. 守护进程退出处理"></a>7. 守护进程退出处理</h2><p>当用户需要外部停止守护进程运行时，往往会使用 kill 命令停止该守护进程。所以，守护进程中需要编码来实现 kill 发出的signal信号处理，达到进程的正常退出。</p>
<p>另外对于某些服务器进程，在请求到来时往往生成子进程处理请求。如果父进程不等待子进程结束，子进程将成为僵尸进程（zombie），从而占用系统资源。如果父进程等待子进程结束，将增加父进程的负担，影响服务器进程的并发性能。在Linux下可以简单地将SIGCHLD信号的操作设为SIG_IGN。这样，子进程结束时不会产生僵尸进程。（这个处理不一定非得有）</p>
<h1 id="典型代码"><a href="#典型代码" class="headerlink" title="典型代码"></a>典型代码</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;assert.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;time.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;stat.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;* 1、创建子进程，父进程退出 *&#x2F;</span><br><span class="line">	if (fork() !&#x3D; 0)</span><br><span class="line">	&#123;</span><br><span class="line">		exit(0);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;* 2、setsid()创建会话 *&#x2F;</span><br><span class="line">	setsid();</span><br><span class="line">	</span><br><span class="line">	&#x2F;* 3、再次fork，父进程退出，即使新进程不再是会话首进程 *&#x2F;</span><br><span class="line">	if (fork() !&#x3D; 0)</span><br><span class="line">	&#123;</span><br><span class="line">		exit(0);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;* 4、让根目录成为子进程的工作目录 *&#x2F;</span><br><span class="line">	chdir(&quot;&#x2F;&quot;);</span><br><span class="line"></span><br><span class="line">	&#x2F;* 5、清空掩码，大大增强该守护进程的灵活性 *&#x2F;</span><br><span class="line">	umask(0);</span><br><span class="line"></span><br><span class="line">	&#x2F;* 6、清空所有文件描述符，让其不占用系统资源 *&#x2F;</span><br><span class="line">	int maxfd &#x3D; getdtablesize();</span><br><span class="line">	int i &#x3D; 0;</span><br><span class="line">	for (; i &lt; maxfd; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		close(i);</span><br><span class="line">	&#125;</span><br><span class="line">&#x2F;&#x2F; 忽略子进程退出信号，避免未处理导致子进程处于僵尸进程</span><br><span class="line">	signal(SIGCHLD,SIG_IGN);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;   !!!后面这里就是主业务代码!!!</span><br><span class="line">	&#x2F;* 每隔5s将当前时间写入日志文件 *&#x2F;</span><br><span class="line">	while (1)</span><br><span class="line">	&#123;</span><br><span class="line">		FILE* fp &#x3D; fopen(&quot;&#x2F;home&#x2F;zy&#x2F;Learn&#x2F;a.log&quot;, &quot;a+&quot;);</span><br><span class="line">		if (fp &#x3D;&#x3D; NULL)</span><br><span class="line">		&#123;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		time_t tv;</span><br><span class="line">		time(&amp;tv);</span><br><span class="line">		fprintf(fp, &quot;Time is %s&quot;, asctime(localtime(&amp;tv)));</span><br><span class="line">		fclose(fp);</span><br><span class="line">		sleep(5);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	exit(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以直接通过库daemon函数来创建来守护进程。</p>
<h2 id="伪业务守护进程脚本"><a href="#伪业务守护进程脚本" class="headerlink" title="伪业务守护进程脚本"></a>伪业务守护进程脚本</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;sh</span><br><span class="line">while true;</span><br><span class="line">do</span><br><span class="line">  count&#x3D;$(ps -ef | grep -c server) #查找当前的进程中，计算server程序的数量</span><br><span class="line">  if [ $count -lt 3 ]; then        #判断服务器进程的数量是否小于3（根据实际填上你的服务器进程数量）</span><br><span class="line">    server start                   #这里填入需要重启的服务器进程</span><br><span class="line">  fi</span><br><span class="line">  sleep 2                          #睡眠2s，周期性地检测服务器程序是不是崩溃了</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<h1 id="hohub-和-amp"><a href="#hohub-和-amp" class="headerlink" title="hohub 和 &amp;"></a>hohub 和 &amp;</h1><p>sighup（挂断）信号在控制终端或者控制进程死亡时向关联会话中的进程发出，默认进程对SIGHUP信号的处理时终止程序，所以我们在shell下建立的程序，在登录退出连接断开之后，会一并退出。</p>
<p>nohup，故名思议就是忽略SIGHUP信号，一般搭配&amp; 一起使用，&amp;表示将此程序提交为后台作业或者说后台进程组。</p>
<p>nohup与&amp;启动的程序， 在终端还未关闭时，完全不像传统的守护进程，因为其不是会话首进程且持有终端，只是其忽略了SIGHUP信号，</p>
<p>从nohup源码就可以看到，其实nohup只做了3件事情</p>
<ol>
<li>dofile函数将输出重定向到nohup.out文件</li>
<li>signal函数设置SIGHUP信号处理函数为SIG_IGN宏（指向sigignore函数），以此忽略SIG_HUP信号</li>
<li>execvp函数用新的程序替换当前进程的代码段、数据段、堆段和栈段。</li>
</ol>
<p>execvp 函数执行后，新程序（并没有fork进程）会继承一些调用进程属性，比如：进程id、会话id，控制终端等。</p>
<p>在终端关闭后，nohup起到类似守护进程的效果，但是跟传统的守护进程还是有区别的</p>
<ol>
<li>nohup创建的进程工作目录是你执行命令时所在的目录</li>
<li>0 1 2 标准输入 标准输出 标准错误  指向nohup.out文件</li>
<li>nohup创建的进程组中，除首长进程的父进程id变为1之外，其余进程依然保留原来的会话id、进程组id、父进程id，都保持不变</li>
</ol>
<p>使用 nohup 和 &amp;，可以使得关闭终端后依然可以使得程序继续运行</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="https://blog.csdn.net/linkedin_35878439/article/details/81288889" target="_blank" rel="noopener">https://blog.csdn.net/linkedin_35878439/article/details/81288889</a>    </li>
<li><a href="http://www.ruanyifeng.com/blog/2016/02/linux-daemon.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/02/linux-daemon.html</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html</a></li>
<li><a href="https://blog.csdn.net/ZYZMZM_/article/details/89436310" target="_blank" rel="noopener">https://blog.csdn.net/ZYZMZM_/article/details/89436310</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>守护进程</tag>
      </tags>
  </entry>
  <entry>
    <title>QT多线程</title>
    <url>/2020/05/12/QT/QT-%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="理解不同的连接方式"><a href="#理解不同的连接方式" class="headerlink" title="理解不同的连接方式"></a>理解不同的连接方式</h2><p>Qt::AutoConnection<br>自动连接：（默认值）如果信号在接收者所依附的线程内发射，则等同于直接连接。如果发射信号的线程和接受者所依附的线程不同，则等同于队列连接。</p>
<p>Qt::DirectConnection<br>直接连接：当信号发射时，槽函数将直接被调用。无论槽函数所属对象在哪个线程，槽函数都在发射信号的线程内执行。</p>
<p>Qt::QueuedConnection<br>队列连接：当控制权回到接受者所依附线程的事件循环时，槽函数被调用。槽函数在接收者所依附线程执行。也就是说：这种方式既可以在线程内传递消息，也可以跨线程传递消息</p>
<p>Qt::BlockingQueuedConnection<br>与Qt::QueuedConnection类似，但是会阻塞等到关联的slot都被执行。这里出现了阻塞这个词，说明它是专门用来多线程间传递消息的</p>
<p>怎么理解上面的话呢？我总结起来有如下几个关键点：</p>
<ol>
<li>每个线程都有自己的栈空间，每个线程都拥有很多对象。一个QThread对象就代表一个线程，对象必定属于某一个线程。</li>
<li>connect语句的位置不太重要，因为它仅仅是将两个对象关联，重要的就是这个对象的关联关系。</li>
<li>发射信号的语句执行的线程 与  接受者所生存的线程有关系就影响者代码到底是在哪个线程中执行的问题。</li>
<li>QThread的start信号发射语句所执行的线程即不是调用语句所在的线程，也不是目标线程。可以认为是一个运行在一个临时的次线程空间中。</li>
</ol>
<p>QThread在次线程中发射start信号，最终创建一个新的线程，新的线程的起点就是run函数，默认就是执行exec处理线程的消息循环。因此，QT使用线程有两种方式，一种是子类化QThread并重写run函数。另外一种是创建一个无父对象的QObject对象，将QObject移动到QThread中，因为没有重写run函数，因此在start后新线程一种在处理消息循环。通过信号槽机制，可以需要的代码放入到新线程中执行。</p>
<h2 id="QtConcurrent"><a href="#QtConcurrent" class="headerlink" title="QtConcurrent"></a>QtConcurrent</h2><p>一种不需要关心底层线程，可以自动并行执行的方法。比如，自动并行处理一些数据。一般GUI编程中这个用到的会比较少。</p>
<p><a href="https://www.fearlazy.com/index.php/post/94.html" target="_blank" rel="noopener">1. QtConcurrent::run</a><br><a href="https://www.fearlazy.com/index.php/post/95.html" target="_blank" rel="noopener">2. QtConcurrent::map</a><br><a href="https://www.fearlazy.com/index.php/post/96.html" target="_blank" rel="noopener">3. QtConcurrent::filter</a></p>
<p>相关类有：QFuture、QFutureWatcher</p>
<h2 id="线程相关"><a href="#线程相关" class="headerlink" title="线程相关"></a>线程相关</h2><p>加锁，事件唤醒主要有如下的类：QMutex, QWaitCondition、QReadLocker、QReadWriteLock、QMutexLocker、QWriteLocker、QSemaphore<br>QWaitCondition必须与QMutex或者QReadwriteLock一起用</p>
]]></content>
      <categories>
        <category>QT</category>
      </categories>
      <tags>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt使用笔记</title>
    <url>/2018/05/24/QT/QT-%E7%90%86%E8%A7%A3QT%E5%BC%80%E5%8F%91%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h2 id="窗口相关概念"><a href="#窗口相关概念" class="headerlink" title="窗口相关概念"></a>窗口相关概念</h2><p>QT中跟GUI相关概念都是QWidget，但是QWidget不等同于窗口。 一个QWidget如果不是嵌入到它的父QWidget中成为QWidget中的一部分的话，就可以把这个QWidget当作一个Window。一个QWidget如果没有父对象，可以认为是一个Window。</p>
<p>QMainWindow是一个特殊的QWidget，通常它没有父QWidget，它也是一个Window。它默认包含了一些常用的组件，比如：状态栏、标题栏、菜单栏、工具栏、浮动工具栏等。通常需要弹出一个新的Window的时候就会用到QDialog，因为QDialog通常不是用来嵌入到父QWidget中来显示的，因此，它也是一个Window。</p>
<p>QT中的对象按照树形来管理，同一个Window如果有两个子Window，需要注意他们有个顺序显示的问题，可能其中一个会挡住另外一个。</p>
<h2 id="事件系统"><a href="#事件系统" class="headerlink" title="事件系统"></a>事件系统</h2><h3 id="发送事件"><a href="#发送事件" class="headerlink" title="发送事件"></a>发送事件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">QApplication::postEvent(_mainWindow, event); </span><br><span class="line">QApplication::sendEvent(_mainWindow, event);</span><br></pre></td></tr></table></figure>

<h3 id="在消息分发成前就处理"><a href="#在消息分发成前就处理" class="headerlink" title="在消息分发成前就处理"></a>在消息分发成前就处理</h3><p>可以重写bool QCoreApplication::notify(QObject *receiver, QEvent *event)虚函数，默认的行为就是调用接收对象的event接口，我们可以改变这个行为，以及阻断这个行为。这也是Qt框架内部处理消息分发的默认接口，postEvent、sendEvent接口后最终都是调用这个接口。</p>
<p>在这里可以处理所有线程的事件。</p>
<h3 id="在消息分发前通过过滤器拦截事件"><a href="#在消息分发前通过过滤器拦截事件" class="headerlink" title="在消息分发前通过过滤器拦截事件"></a>在消息分发前通过过滤器拦截事件</h3><p>为QCoreApplication::instance()安装一个事件过滤器。这个事件过滤器就能处理所有控件的所有事件，因此这与重写notify()一样强大；此外，可以有不止一个应用程序全局级的事件过滤器，应用程序全局级事件过滤器甚至可以收到已禁用控件的鼠标事件。</p>
<p>注意：应用程序级事件过滤器仅能用于存活在主线程中的对象。</p>
<p>过滤器的默认接口是如下形式，任何对象只要有如下的接口都可以被安装作为过滤器。Qt窗口相关的类默认已经提供了它的虚函数，我们重新实现就行，但是还得使用installEventFilter(this); 方法来注册过滤器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 返回true阻止事件传播，返回false可以继续传播。</span><br><span class="line">bool QObject::eventFilter(QObject *watched, QEvent *event)</span><br></pre></td></tr></table></figure>

<h3 id="给目标对象添加过滤器"><a href="#给目标对象添加过滤器" class="headerlink" title="给目标对象添加过滤器"></a>给目标对象添加过滤器</h3><p>针对具体某个对象的事件处理添加过滤器，比全局的影响小很多。</p>
<h3 id="更改目标对象的事件处理逻辑"><a href="#更改目标对象的事件处理逻辑" class="headerlink" title="更改目标对象的事件处理逻辑"></a>更改目标对象的事件处理逻辑</h3><p>经过了前面的处理之后，某个对象要处理某个事件，必定是通过它的event方法来分发的，因此可以在这里重写QObject::event()进行控制。</p>
<h3 id="在目标对象内重写事件响应函数"><a href="#在目标对象内重写事件响应函数" class="headerlink" title="在目标对象内重写事件响应函数"></a>在目标对象内重写事件响应函数</h3><p>具体某个某个事件通过重重的分发过滤，最终可能到达某个具体的响应函数来达到我们的目的，比如paintEvent()、mousePressEvent，就是针对的具体的事件。我们也可以重写具体的事件来达到控制的目的。</p>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>除了传统的创建多线程方式，Qt还指针将一个对象移动到QThread中，只有独立的QObject对象（没有父QObject）才能被移动进入线程，对象最好是new出来的。这种方式其实本质上就是利用了信号槽的机制。槽函数如果在另外的线程中，触发时将在对方的线程中处理。</p>
<h3 id="资源清理"><a href="#资源清理" class="headerlink" title="资源清理"></a>资源清理</h3><p>一旦将一个QObject对象移动到QTread中后，除了在线程中进行删除外，其它地方都无权限进行删除。而在线程中删除的最好时机是用信号，使用如下的代码：<br>connect(&amp;_thread, &amp;QThread::finished, this, &amp;WzTransientImp::deleteLater);</p>
<h3 id="线程退出"><a href="#线程退出" class="headerlink" title="线程退出"></a>线程退出</h3><p>如果线程不涉及到消息循环，仅仅是普通的while循环代码，退出只需要通过控制循环条件来退出即可。</p>
<p>对于涉及到Qt的内部机制的线程退出，暂时还未研究！</p>
<h2 id="使用TIPS"><a href="#使用TIPS" class="headerlink" title="使用TIPS"></a>使用TIPS</h2><h3 id="标题栏处理"><a href="#标题栏处理" class="headerlink" title="标题栏处理"></a>标题栏处理</h3><p>在属性里面将最大窗口大小和最小的窗口都设置成一样可以使得最大化按钮不可用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this-&gt;setWindowFlags(Qt::Dialog|Qt::FramelessWindowHint);</span><br></pre></td></tr></table></figure>

<h3 id="QtableWidget设置列宽"><a href="#QtableWidget设置列宽" class="headerlink" title="QtableWidget设置列宽"></a>QtableWidget设置列宽</h3><h3 id="发布程序"><a href="#发布程序" class="headerlink" title="发布程序"></a>发布程序</h3><h4 id="Windows平台"><a href="#Windows平台" class="headerlink" title="Windows平台"></a>Windows平台</h4><p>你用哪个编译编译的程序就去哪个目录下查找windeployqt.exe。在开始菜单中，可以直接选择对应编译器的CMD，点击后就直接进入了相应的目录。然后进入bin目录，可以尝试运行windeployqt.exe –help 看能否打印帮助。</p>
<p>将你的qtcreator生成的文件拷贝到某个目录下，比如<code>F:\tmp</code>，然后CMD中运行 <code>windeployqt.exe F:\tmp\WzPQMTool.ex</code>即可</p>
<h4 id="嵌入式平台"><a href="#嵌入式平台" class="headerlink" title="嵌入式平台"></a>嵌入式平台</h4><p>又分为两种情况：一种是控制台程序、一种是GUI程序。</p>
<p>对于控制台程序，只需要将libQt5Core.so.5文件和preloadable_iconv.so文件拷贝到嵌入式设备。在运行前指定如下的两个变量即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export LD_PRELOAD&#x3D;&#x2F;usr&#x2F;lib&#x2F;preloadable_libiconv.so</span><br><span class="line">export LD_LIBRARY_PATH&#x3D;$LD_LIBRARY_PATH:$QTDIR&#x2F;lib:&#x2F;lib:&#x2F;usr&#x2F;local&#x2F;lib</span><br></pre></td></tr></table></figure>

<p>对于GUI程序，目前还没有去研究。但是从已有真的知识可以判断，还需要指定font目录、指定plugin目录。</p>
<h3 id="升级Qt组件"><a href="#升级Qt组件" class="headerlink" title="升级Qt组件"></a>升级Qt组件</h3><p><a href="https://mirrors.tuna.tsinghua.edu.cn/qt/online/qtsdkrepository/windows_x86/root/qt/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/qt/online/qtsdkrepository/windows_x86/root/qt/</a> 下载Updates.xml 以及 qt 目录下的所有文件，同样在你电脑上建立qt目录，将文件原样放入qt目中。</p>
<p>用编辑器打开Updates.xml，替换所有库的URL 到清华镜像站，查找 “<a href="http://download.qt.io/”" target="_blank" rel="noopener">http://download.qt.io/”</a> 替换成 “<a href="https://mirrors.tuna.tsinghua.edu.cn/qt/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/qt/</a> “ (如果是中科大站，使用相应的地址)，然后保存。将Updates.xml 以及qt目录放置到你的一个目录下，记录下目录路径， 如我的 “C:/Qt/ “<br>进入你的MaintenanceTool安装目录，一般是QT的安装目录，删除MaintenanceTool.ini，然后运行MaintenanceTool工具。<br>选择更新或者“添加或移除组件”，点击左下方设置，进入存储库设置。<br>取消勾选所有已有的存储库，选中 “用户定义储存库”,点击添加，将你本地的Updates.xml的目录输入，可以点击测试检测目录是否正确，然后点击OK保存。</p>
]]></content>
      <categories>
        <category>QT</category>
      </categories>
      <tags>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title>QT处理目录和文件</title>
    <url>/2020/05/13/QT/QT-%E7%9B%AE%E5%BD%95%E5%92%8C%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>QT中使用QDir来表示目录。</p>
<ul>
<li>如何构造一个QDir对象：使用表示目录的路径字符串，路径是否以”/“结尾不重要。</li>
<li>与新的路径字符串拼凑得到一个新路径字符串： absoluteFilePath 和 filePath，不检查路径是否真实存在，路径中可存在”.”,”..”</li>
<li>目录的绝对路径：absolutePath，不以”/“结尾</li>
<li>其它文件相当于本目录的相对路径：relativeFilePath</li>
<li>查找目录下的文件，可以指定查找规则，指定过滤规则，指定排序规则：entryInfoList、entryList <strong>不会递归查找</strong></li>
<li>得到描述本目录的路径字符串：path(), 描述本路径可以是绝对路径，可以是相对路径</li>
<li>将内部描述本路径的字符串转成绝对路径：makeAbsolute</li>
<li>创建子目录：mkdir</li>
<li>递归创建子目录：mkpath，子目录也可以是与本目录无关的绝对路径</li>
<li>删除子目录下的文件：remove，只要传入的是一个文件，且文件存在就可以，可以是根目录无关的绝对路径。</li>
<li>删除本目录以及本目录下的全部文件：removeRecursively</li>
<li>重命名：rename，借助重命名可以移动文件和文件夹。</li>
<li>删除子目录：rmdir，被删除的目录必须为空目录。可以根本目录没有关系。</li>
</ul>
<p>总结，很多的接口都可以指定一个子目录/文件的路径，但是其实子目录可以是跟本目录没有直接父子关系的任意目录/文件。关于增删改建议使用如下的接口：</p>
<p>全局静态方法有：</p>
<ul>
<li>cleanPath： 清理路径中不必要的”.”,”..”，整理字符串。</li>
<li>current/currentPath</li>
<li>home/homePath</li>
<li>root/rootPath</li>
<li>temp/tempPath</li>
<li>toNativeSeparators</li>
<li>fromNativeSeparators</li>
</ul>
<p>除了系统预定的一些目录，比如home/root/current等，项目中还可以手动指定一个名称，给他关联到N个目录，可以同时在这N个目录中进行查找子目录等。这个就是利用到的setSearchPaths、addSearchPath</p>
<p>Poco中使用Poco::Path来表示一个文件或者路径，构造时，如果以”/“结尾则表示目录。</p>
<h2 id="文件信息"><a href="#文件信息" class="headerlink" title="文件信息"></a>文件信息</h2><p>QT中使用QFileInfo来表示一个文件，目录也是一个特殊的文件。在构建的时候，是否有”/“结尾就很重要了。QT的QFileInfo设计得并不好，相关接口很容易混淆，同样的接口在对文件和目录时，差别很大。</p>
<p>表示一个文件的，总是有3属性：位置，也可以说时path/dir ；文件名；完整路径描述，filePath;</p>
<ul>
<li>构建一个QFileInfo，QString、QDir和QString结合、QFile都能表示一个文件，因此都可以用来创建QFileInfo。</li>
<li>文件所在目录：absoluteDir，absolutePath，Dir</li>
<li>目录的位置，非上级目录，不以”/“结尾：absoluteDir，absolutePath</li>
<li>描述FileInfo的内部描述字符串： filePath</li>
<li>内部描述字符串的绝对路径形式，仅仅是路径展开成绝对路径，absoluteFilePath</li>
<li>文件的基本名：baseName、completeBaseName, 目录的基本名为空。</li>
<li>isFile,isDir会去查看这个文件系统是否真的存在该文件/目录</li>
</ul>
<p>构造时，如果以”/“结尾，则当作是目录来处理。至于isFile,isDir返回结果会检查文件系统这是另外一回事。当把它当作目录是，可以看成是位置Path为本身，文件名为空的特殊文件，这样在理解获取相关位置的接口时比较方便。获取位置时，返回的字符串总是不以”/“结束。说它设计的不好是因为，我们在利用QFileInfo获取文件相关信息是，总是无法避免无法正确的处理结尾的分隔符”/“。</p>
<p>Poco中使用Poco::File来描述文件。</p>
<h2 id="常用操作总结"><a href="#常用操作总结" class="headerlink" title="常用操作总结"></a>常用操作总结</h2><ol>
<li>递归新建目录使用 QDir::mkpath</li>
<li>菲递归创建目录使用  QDir::mkdir</li>
<li>只删除空目录使用 QDir::rmdir</li>
<li>强制递归删除目录使用 QDir::removeRecusively</li>
<li>删除文件使用 QDir::remove, QFile::remove(静态方法）</li>
<li>移动和重命名目录使用 QDir::rename</li>
<li>移动和重命名文件使用 QDir::rename, QFile::rename(有静态方法)</li>
<li>复制文件： QFile::copy(静态方法）</li>
<li>判断是否存在： QFile::exists(静态方法),QFileInfo::exists(静态方法)</li>
</ol>
]]></content>
      <categories>
        <category>QT</category>
      </categories>
      <tags>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title>QT相关类使用总结</title>
    <url>/2018/05/24/QT/QT-%E7%9B%B8%E5%85%B3%E7%B1%BB%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="QByteArray"><a href="#QByteArray" class="headerlink" title="QByteArray"></a>QByteArray</h2><ul>
<li>创建一个空间，方便读写内部的各个字节。</li>
<li>创建空间时，会在最后的存储空间添加一个’\0’，但是这个空间不算是size的范围内。这个添加的’\0’不同于字符串中的’\0’,它是特殊的。使用constData获取字符串时，会忽略前面的字符串0而直到末尾的0。所以，可以在里面存储’\0’而不用担心。</li>
<li>不同的构造函数关键点就是空间大小，有些是明确指定，有些是需要从字符串隐含计算。可以在需要的是否手动调整空间大小。</li>
<li>也有不创建空间而构造出QByteArray的方法，因为不创建空间，末尾没有特殊标记的’\0’，因此在使用api时需要特别小心。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">QByteArray <span class="title">ba1</span><span class="params">(<span class="string">"ca\0r\0t"</span>)</span></span>;</span><br><span class="line">ba1.size();                     <span class="comment">// Returns 2.</span></span><br><span class="line">ba1.constData();                <span class="comment">// Returns "ca" with terminating \0.</span></span><br><span class="line"></span><br><span class="line"><span class="function">QByteArray <span class="title">ba2</span><span class="params">(<span class="string">"ca\0r\0t"</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">ba2.size();                     <span class="comment">// Returns 3.</span></span><br><span class="line">ba2.constData();                <span class="comment">// Returns "ca\0" with terminating \0.</span></span><br><span class="line"></span><br><span class="line"><span class="function">QByteArray <span class="title">ba3</span><span class="params">(<span class="string">"ca\0r\0t"</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line">ba3.size();                     <span class="comment">// Returns 4.</span></span><br><span class="line">ba3.constData();                <span class="comment">// Returns "ca\0r" with terminating \0.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> cart[] = &#123;<span class="string">'c'</span>, <span class="string">'a'</span>, <span class="string">'\0'</span>, <span class="string">'r'</span>, <span class="string">'\0'</span>, <span class="string">'t'</span>&#125;;</span><br><span class="line"><span class="function">QByteArray <span class="title">ba4</span><span class="params">(QByteArray::fromRawData(cart, <span class="number">6</span>))</span></span>;</span><br><span class="line">ba4.size();                     <span class="comment">// Returns 6.</span></span><br><span class="line">ba4.constData();                <span class="comment">// Returns "ca\0r\0t" without terminating \0.</span></span><br></pre></td></tr></table></figure>

<h2 id="大小端转换"><a href="#大小端转换" class="headerlink" title="大小端转换"></a>大小端转换</h2><p>首先，为什么会有小端字节序？</p>
<p>答案是，计算机电路先处理低位字节，效率比较高，因为计算都是从低位开始的。所以，计算机的内部处理都是小端字节序。但是，人类还是习惯读写大端字节序。所以，除了计算机的内部处理，其他的场合几乎都是大端字节序，比如网络传输和文件储存。</p>
<p>计算机处理字节序的时候，不知道什么是高位字节，什么是低位字节。它只知道按顺序读取字节，先读第一个字节，再读第二个字节。所谓的第一个字节就是低地址上的存储的数据。所谓的小端就是先读取到的是数据的地位内容，因此，在大部分的平台上，处理器都是小端存储的。</p>
<p>如果是大端字节序，先读到的就是高位字节，后读到的就是低位字节。小端字节序正好相反。这就是以下这一句话背后的理解。</p>
<pre><code>“big-endian 是高位的放在内存低地址处，低位的放在高地址处。little-endian 是高位的放在内存高地址处，低位的放在低地址处。”</code></pre><p>字节序的处理，只有在两台不同平台的设备间交互数据时才需要注意。比如通过网络交换数据，通过文件交换数据时。</p>
<p>QT上处理字节序的接口是:</p>
<ul>
<li>qToBigEndian</li>
<li>qFromBigEndian</li>
</ul>
<p>都是模板方法，注意通常有两种使用方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">qToBigEndian&lt;uint16_t&gt;(cmd.data(), 1, cmd.data()); </span><br><span class="line">len &#x3D; qToBigEndian(len);</span><br></pre></td></tr></table></figure>

<h2 id="QLibaray"><a href="#QLibaray" class="headerlink" title="QLibaray"></a>QLibaray</h2><p>使用QLibaray来load动态库文件时，除了dll文件本身必须要存在的话，dll所依赖的dll也必须能被加载，否则就会导致加载失败。</p>
<h2 id="QDir"><a href="#QDir" class="headerlink" title="QDir"></a>QDir</h2><p>一个QDir对象表示一个目录，围绕着目录可以做很多得处理。</p>
<ul>
<li>mkpath  递归创建多级目录</li>
<li>mkdir  创建子目录</li>
<li>absolutePath 目录的绝对路径</li>
<li></li>
</ul>
<h2 id="QFileInfo"><a href="#QFileInfo" class="headerlink" title="QFileInfo"></a>QFileInfo</h2><p>一个QFileInfo表示一个文件，围绕着文件可以做很多得处理。描述一个文件可以有多种方法，如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 三种构建方法</span></span><br><span class="line">QFileInfo(<span class="keyword">const</span> QString &amp;file)</span><br><span class="line">QFileInfo(<span class="keyword">const</span> QFile &amp;file)</span><br><span class="line">QFileInfo(<span class="keyword">const</span> QDir &amp;dir, <span class="keyword">const</span> QString &amp;file)</span><br></pre></td></tr></table></figure>

<ul>
<li></li>
</ul>
]]></content>
      <categories>
        <category>QT</category>
      </categories>
      <tags>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title>QT相关类使用总结</title>
    <url>/2020/05/10/QT/QT%E4%BD%BF%E7%94%A8COM%E6%9D%A5%E7%94%9F%E6%88%90%E6%96%87WORD%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<p>COM是一种二进制兼容的接口，在windows平台上，可以使用任何的语言来通过COM调用。WORD在安装时已经在计算机上注册了相应的COM接口，理论上使用任意语言都可以调用其接口来生成WORD文档。</p>
<h2 id="WORD的COM接口资料"><a href="#WORD的COM接口资料" class="headerlink" title="WORD的COM接口资料"></a>WORD的COM接口资料</h2><p>有多种途径：</p>
<ol>
<li>通过官方的VBA资料可以查看有哪些接口，可以尝试用C++使用。</li>
<li>用第三方工具dumpcpp可以直接将COM接口文件的接口导出成HTML</li>
<li>使用QT提供的内部接口，可以查询并导出相应的接口文件。</li>
</ol>
<h2 id="QT中使用"><a href="#QT中使用" class="headerlink" title="QT中使用"></a>QT中使用</h2><p>在QT中QAxObject对象表示一个COM接口对象。</p>
<h3 id="查询COM接口对象所支持的方法和属性"><a href="#查询COM接口对象所支持的方法和属性" class="headerlink" title="查询COM接口对象所支持的方法和属性"></a>查询COM接口对象所支持的方法和属性</h3><p>调用COM对象QAxObject的方法generateDocumentation可以得到一个字符串描述的接口，可以将其输出到HTML文件中来查看。比如如下的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void QWord::createHtml(QString file, QAxObject *obj)</span><br><span class="line">&#123;</span><br><span class="line">    QFile htmlFile(file + &quot;.html&quot;);</span><br><span class="line">    if(!htmlFile.exists())</span><br><span class="line">    &#123;</span><br><span class="line">        if (htmlFile.open(QIODevice::WriteOnly | QIODevice::Text))</span><br><span class="line">        &#123;</span><br><span class="line">            QString text &#x3D; obj-&gt;generateDocumentation();</span><br><span class="line">            QTextStream txtOutput5(&amp;htmlFile);</span><br><span class="line">            txtOutput5 &lt;&lt; text &lt;&lt; endl;</span><br><span class="line">            htmlFile.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="调用COM接口对象的方法"><a href="#调用COM接口对象的方法" class="headerlink" title="调用COM接口对象的方法"></a>调用COM接口对象的方法</h3><p>可以使用<code>dynamicCall</code> 或者 <code>querySubObject</code> 来调用。两个方法的参数1都是对所调用的COM对象的方法原型描述，其后的都是各个参数，比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">activeX-&gt;dynamicCall(&quot;Navigate(const QString&amp;)&quot;, &quot;www.qt-project.org&quot;);</span><br><span class="line">activeX-&gt;querySubObject(&quot;Navigate(const QString&amp;)&quot;, &quot;www.qt-project.org&quot;);</span><br></pre></td></tr></table></figure>
<p>这两个接口都可以达到调用方法的目的，他们的区别是一个返回QVariant对象，一个返回QAxOjbect指针。但是，QVarient也可以转换为QAxObject指针的。</p>
<p>另外dynamicCall调用时还可以有简写模式，比如前面的代码，可以简化为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">activeX-&gt;dynamicCall(&quot;Navigate(\&quot;www.qt-project.org\&quot;)&quot;);</span><br></pre></td></tr></table></figure>

<h3 id="读COM接口对象的属性"><a href="#读COM接口对象的属性" class="headerlink" title="读COM接口对象的属性"></a>读COM接口对象的属性</h3><p>推荐使用QObject::property的方法，因为QAxOjbect也是QObject的字类，这种方式是最高效的。</p>
<p>也可以使用dynamicCall和querySubObject来调用。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">QString text &#x3D; activeX-&gt;dynamicCall(&quot;Text&quot;).toString();</span><br><span class="line">m_word-&gt;querySubObject(&quot;Documents&quot;);</span><br></pre></td></tr></table></figure>

<h3 id="写COM接口对象的属性"><a href="#写COM接口对象的属性" class="headerlink" title="写COM接口对象的属性"></a>写COM接口对象的属性</h3><p>推荐使用QObject::setProperty的方法，因为QAxOjbect也是QObject的字类，这种方式是最高效的。<br>也可以使用dynamicCall和querySubObject来调用。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">activeX-&gt;dynamicCall(&quot;Value&quot;, 5);</span><br></pre></td></tr></table></figure>

<h3 id="传参问题"><a href="#传参问题" class="headerlink" title="传参问题"></a>传参问题</h3><p>如果接口参数过多的话，对于有默认值的参数，可以不必再dynamicCall函数中说明，直接忽略。比如有如下的接口：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;Open(QVariant&amp;, QVariant&amp;, QVariant&amp;, QVariant&amp;, QVariant&amp;, QVariant&amp;, QVariant&amp;, QVariant&amp;, QVariant&amp;, QVariant&amp;, QVariant&amp;, QVariant&amp;, QVariant&amp;, QVariant&amp;, QVariant&amp;, QVariant&amp;)&quot;</span><br></pre></td></tr></table></figure>
<p>在调用方法时，除去第1个，其它全部都有默认值，不是非必须的。因此，实际使用时可以根据需要来生命函数原型。比如如下的使用就是正确的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">documents-&gt;dynamicCall(&quot;Open (const QVariant&amp;)&quot;, m_strFilePath);</span><br></pre></td></tr></table></figure>

<h3 id="总结建议"><a href="#总结建议" class="headerlink" title="总结建议"></a>总结建议</h3><p>读写属性毫无疑问使用QObject的那套机制。函数调用，如果是方法的返回值是COM对象的话，建议使用querySubObject，如果方法无返回值或者返回非COM对象的话，建议使用dynamicCall。</p>
]]></content>
      <categories>
        <category>QT</category>
      </categories>
      <tags>
        <tag>WORD</tag>
        <tag>COM</tag>
      </tags>
  </entry>
  <entry>
    <title>移植Qt5.7到嵌入式Linux系统</title>
    <url>/2019/01/24/QT/QT-%E7%A7%BB%E6%A4%8DQt5-7%E5%88%B0%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>最近由于手上的ARM开发板升级到了3.14，所以也打算将Qt的开发环境由4.8.5 升级到 5.7/5.9 。主要是因为实际使用发现，在4.8.5的平台上Qt有不少的Bug，由此担心稳定性问题。另外，Qt5是Qt的未来，借此可以进一步学习Qt5的开发，新的系统所配置的交叉编译工具链也支持c++11的开发，借此也可以体验下。</p>
<a id="more"></a>

<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><ol>
<li>准备一个Linux 64位的机器，虚拟机也行。</li>
<li>准备一个嵌入式交叉编译工具，这里我用的是 <a href="https://releases.linaro.org/components/toolchain/binaries/latest-7/arm-linux-gnueabihf/" target="_blank" rel="noopener">gcc-linaro-4.9-2016.02-x86_64_arm-linux-gnueabihf.tar.xz</a>。<br>并且配置好环境变量：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export ARCH&#x3D;arm</span><br><span class="line">export CROSS_COMPILE&#x3D;&#x2F;opt&#x2F;arm-linux-gnueabihf&#x2F;bin&#x2F;arm-linux-gnueabihf-</span><br><span class="line">export PATH&#x3D;&#x2F;opt&#x2F;arm-linux-gnueabihf&#x2F;bin&#x2F;:$PATH</span><br></pre></td></tr></table></figure></li>
<li>下载Qt5.7源码</li>
<li>创建编译后的安装目录 /opt/qt570-arm</li>
</ol>
<h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><h2 id="编译Qt-SDK"><a href="#编译Qt-SDK" class="headerlink" title="编译Qt SDK"></a>编译Qt SDK</h2><h3 id="自定义xplatform平台"><a href="#自定义xplatform平台" class="headerlink" title="自定义xplatform平台"></a>自定义xplatform平台</h3><p>进入qtbase/mkspec，修改现有的平台<strong>linux-g++ linux-arm-gnueabi-g++</strong>下的qmake.conf文件。支持linuxfb插件的配置修改后的内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#</span><br><span class="line"># qmake configuration for building with arm-linux-gnueabi-g++</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line">MAKEFILE_GENERATOR      &#x3D; UNIX</span><br><span class="line">CONFIG                 +&#x3D; incremental</span><br><span class="line">QMAKE_INCREMENTAL_STYLE &#x3D; sublib</span><br><span class="line">QT_QPA_DEFAULT_PLATFORM &#x3D; linuxfb</span><br><span class="line">QMAKE_CFLAGS_RELEASE +&#x3D; -O2 -march&#x3D;armv7-a</span><br><span class="line">QMAKE_CXXFLAGS_RELEASE +&#x3D; -O2 -march&#x3D;armv7-a</span><br><span class="line"></span><br><span class="line">include(..&#x2F;common&#x2F;linux.conf)</span><br><span class="line">include(..&#x2F;common&#x2F;gcc-base-unix.conf)</span><br><span class="line">include(..&#x2F;common&#x2F;g++-unix.conf)</span><br><span class="line"></span><br><span class="line"># modifications to g++.conf</span><br><span class="line">QMAKE_CC                &#x3D; arm-linux-gnueabihf-gcc</span><br><span class="line">QMAKE_CXX               &#x3D; arm-linux-gnueabihf-g++</span><br><span class="line">QMAKE_LINK              &#x3D; arm-linux-gnueabihf-g++</span><br><span class="line">QMAKE_LINK_SHLIB        &#x3D; arm-linux-gnueabihf-g++</span><br><span class="line"></span><br><span class="line"># modifications to linux.conf</span><br><span class="line">QMAKE_AR                &#x3D; arm-linux-gnueabihf-ar cqs</span><br><span class="line">QMAKE_OBJCOPY           &#x3D; arm-linux-gnueabihf-objcopy</span><br><span class="line">QMAKE_NM                &#x3D; arm-linux-gnueabihf-nm -P</span><br><span class="line">QMAKE_STRIP             &#x3D; arm-linux-gnueabihf-strip</span><br><span class="line">load(qt_config)</span><br></pre></td></tr></table></figure>

<h3 id="使用configure工具生成makefile"><a href="#使用configure工具生成makefile" class="headerlink" title="使用configure工具生成makefile"></a>使用configure工具生成makefile</h3><p>进入到源码根目录，创建一个build.sh文件，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;sh</span><br><span class="line"></span><br><span class="line">.&#x2F;configure -verbose \</span><br><span class="line">-prefix &#x2F;opt&#x2F;qt570-arm \</span><br><span class="line">-opensource \</span><br><span class="line">-confirm-license \</span><br><span class="line">-release \</span><br><span class="line">-shared \</span><br><span class="line">-xplatform linux-arm-gnueabi-g++ \</span><br><span class="line">-optimized-qmake \</span><br><span class="line">-pch \</span><br><span class="line">-qt-sql-sqlite \</span><br><span class="line">-qt-libjpeg \</span><br><span class="line">-qt-zlib \</span><br><span class="line">-qt-libpng \</span><br><span class="line">-no-opengl \</span><br><span class="line">-no-sse2 \</span><br><span class="line">-no-openssl \</span><br><span class="line">-no-nis \</span><br><span class="line">-no-opengl \</span><br><span class="line">-no-cups \</span><br><span class="line">-no-glib \</span><br><span class="line">-no-separate-debug-info \</span><br><span class="line">-no-accessibility \</span><br><span class="line">-nomake examples \</span><br><span class="line">-nomake tests \</span><br><span class="line">-nomake tools \</span><br><span class="line">-skip qtvirtualkeyboard</span><br></pre></td></tr></table></figure>
<p>其中最重要的就是 <code>-prefix /opt/qt570-arm</code> 和 <code>-xplatform linux-arm-gnueabi-g++</code> 这2个选项。这里在前面已经处理好了，/opt/qt570-arm 表示安装目录； linux-arm-gnueabi-g++ 对应 qtbase/mkspec目录下的linux-arm-gnueabi-g++平台文件，编译会根据此目录下的qmake来配置生成makefile。</p>
<p>注意：编译Qt5.9手续要的configure配置与5.7有少许的不同，有些配置选项是无效的，根据提示删除不支持的选项即可。</p>
<h3 id="make-amp-amp-make-install"><a href="#make-amp-amp-make-install" class="headerlink" title="make &amp;&amp; make install"></a>make &amp;&amp; make install</h3><p>前面一步成功之后，使用sudo make -j2 执行即可。编译完成后，再使用sudo make install。</p>
<h2 id="编译tslib"><a href="#编译tslib" class="headerlink" title="编译tslib"></a>编译tslib</h2><p>由于我暂时不需要用到触摸板，因此并不需要tslib库。如有需要，可以上网进一步查询资料进行交叉编译即可</p>
<h2 id="交叉编译libiconv-1-15"><a href="#交叉编译libiconv-1-15" class="headerlink" title="交叉编译libiconv-1.15"></a>交叉编译libiconv-1.15</h2><p>交叉编译libiconv-1.15会得到preloadable_libiconv.so库，交叉编译的命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;configure CC&#x3D;arm-linux-gnueabihf-gcc --prefix&#x3D;&#x2F;home&#x2F;dejary&#x2F;libiconv-1.15-arm --host&#x3D;arm-linux</span><br><span class="line"> $ make</span><br><span class="line"> $ make install</span><br></pre></td></tr></table></figure>
<p>preloadable_libiconv.so在安装目录lib中(/home/dejary/libiconv-1.15-arm/lib)</p>
<h2 id="交叉编译gdb"><a href="#交叉编译gdb" class="headerlink" title="交叉编译gdb"></a>交叉编译gdb</h2><h1 id="QtCreator配置"><a href="#QtCreator配置" class="headerlink" title="QtCreator配置"></a>QtCreator配置</h1><h1 id="部署和运行"><a href="#部署和运行" class="headerlink" title="部署和运行"></a>部署和运行</h1><p>启动程序前必须先设置好相关的环境变量，按照如下的设置即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export QTDIR&#x3D;&#x2F;opt&#x2F;qt570-arm</span><br><span class="line">export PATH&#x3D;$T_ROOT&#x2F;bin:$PATH</span><br><span class="line">export LD_LIBRARY_PATH&#x3D;$LD_LIBRARY_PATH:$QTDIR&#x2F;lib:&#x2F;lib:&#x2F;usr&#x2F;local&#x2F;lib</span><br><span class="line">export QT_QPA_PLATFORM_PLUGIN_PATH&#x3D;$QTDIR&#x2F;plugins</span><br><span class="line">export QT_QPA_PLATFORM&#x3D;linuxfb:fb&#x3D;&#x2F;dev&#x2F;fb0:size&#x3D;800x480</span><br><span class="line">#export QT_QPA_PLATFORM&#x3D;linuxfb:fb&#x3D;&#x2F;dev&#x2F;fb0:size&#x3D;480x272:mmsize&#x3D;95x53:offset&#x3D;0x0</span><br><span class="line">export QT_QPA_FONTDIR&#x3D;$QTDIR&#x2F;lib&#x2F;fonts</span><br><span class="line">export LD_PRELOAD&#x3D;&#x2F;usr&#x2F;lib&#x2F;preloadable_libiconv.so</span><br></pre></td></tr></table></figure>
<p>上述的设置都是必需的选项，其它含义也比较清晰明确。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li></li>
<li></li>
<li><a href="https://linuxszp.github.io/2017/06/05/ubuntu16-04%E7%BC%96%E8%AF%91ARM%E7%89%88Qt5-7-0-%E5%BC%80%E5%8F%91%E6%9D%BF%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/" target="_blank" rel="noopener">ubuntu16.04编译ARM版Qt5.7.0+开发板远程调试</a></li>
</ol>
]]></content>
      <categories>
        <category>QT</category>
      </categories>
      <tags>
        <tag>ARM</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt界面数据存储与获取</title>
    <url>/2019/08/19/QT/Qt%E7%95%8C%E9%9D%A2%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E4%B8%8E%E8%8E%B7%E5%8F%96/</url>
    <content><![CDATA[<p>在GUI开发中，往往需要在界面中存储一些有用的数据，这些数据可以来自配置文件、注册表、数据库、或者是Server。无论来自哪里，这些数据对于用户来说都是至关重要的，它们在交互过程中大部分都会被用到，例如：单击一个用户头像，显示该用户的详细信息（等级、昵称、姓名、个人说明）.</p>
<h1 id="常见接口"><a href="#常见接口" class="headerlink" title="常见接口"></a>常见接口</h1><h2 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h2><p>Qt中，可以通过绝大部分已有的接口来存数数据、获取数据。例如：</p>
<ul>
<li>setData()</li>
<li>setItemData()</li>
<li>data()</li>
<li>itemData()</li>
</ul>
<p>Qt5中取消了setUserData/userData 接口</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>绝大部分存储用户数据的接口都使用的是QVariant，也就是我们常说的“万能变量”。对于自定义数据类型，如果要使用QVariant，就必须使用Q_DECLARE_METATYPE注册。<br>使用使用Qt::UserRole、Qt::UserRole + 1…就能存储多个数据。setItemData的使用也差不多。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pItem-&gt;setData(Qt::UserRole, i);  <span class="comment">// 用户数据</span></span><br><span class="line">pItem-&gt;setData(Qt::UserRole + <span class="number">1</span>, QString(<span class="string">"Qter %1"</span>).arg(i));  <span class="comment">// 用户数据</span></span><br></pre></td></tr></table></figure>

<h1 id="定义控件的子类"><a href="#定义控件的子类" class="headerlink" title="定义控件的子类"></a>定义控件的子类</h1><p>用现有的接口固然方便，有时对于复杂的功能，我们也不得不自定义。<br>举一个简单的例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QPushButton&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PushButton</span> :</span> <span class="keyword">public</span> QPushButton</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">PushButton</span><span class="params">(QWidget *parent = <span class="number">0</span>)</span></span></span><br><span class="line">        : QPushButton (parent),</span><br><span class="line">          m_nID(<span class="number">-1</span>),</span><br><span class="line">          m_strName(<span class="string">""</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setID</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        m_nID = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(QString name)</span> </span>&#123;</span><br><span class="line">       m_strName = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">id</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_nID;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">QString <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_strName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_nID;</span><br><span class="line">    QString m_strName;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>们定义了一个按钮QPushButton，可以通过setID()、setName()来设置ID和名称信息，如果要获取信息，则可以调用id()、name()函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">PushButton *pButton = <span class="keyword">new</span> PushButton(<span class="keyword">this</span>);</span><br><span class="line">pButton-&gt;setText(<span class="string">"Qter"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置自定义数据</span></span><br><span class="line">pButton-&gt;setID(<span class="number">1</span>);</span><br><span class="line">pButton-&gt;setName(<span class="string">"Qter"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接信号槽</span></span><br><span class="line">connect(pButton, &amp;QPushButton::clicked, <span class="keyword">this</span>, &amp;MainWindow::onClicked);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>QT</category>
      </categories>
      <tags>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title>QT零散总结</title>
    <url>/2019/08/16/QT/QT%E9%9B%B6%E6%95%A3%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="基本总结"><a href="#基本总结" class="headerlink" title="基本总结"></a>基本总结</h1><ol>
<li><p>对话框的show()方法并不能是代码阻塞在show方法里面，不管窗口是不是模式的，因为模式窗口跟阻塞完全是两个概念。</p>
</li>
<li><p>界面控件，很多时候需要区分所操作的控件，所以需要在控件中携带很多额外的信息。控件大多是用来显示的，这些额外的信息经常是不需要显示的。这个时候，可以利用组件的角色功能来实现。在QTreeWdiget，QTableWidget，QComboBox，QPushButton中经常可能用到。相关接口有：setData/data, setItemData/itemData, setUserData/userData.</p>
</li>
<li><p>Qt自己为了一个对象树，对于QOjbect子对象的指针，如果指定的父对象的话，我们无需手动去删除指针，对象树会正确的管理好资源。</p>
</li>
<li><p>利用好QObject对象的属性系统</p>
</li>
</ol>
]]></content>
      <categories>
        <category>QT</category>
      </categories>
      <tags>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title>使用QTableWidget</title>
    <url>/2019/08/16/QT/%E4%BD%BF%E7%94%A8QTableWidget/</url>
    <content><![CDATA[<p>QTableWidget适合在少量的数据的时候使用，或者数据不怎么改变的时候使用。</p>
<h1 id="基本设置"><a href="#基本设置" class="headerlink" title="基本设置"></a>基本设置</h1><h2 id="设置行列数据和表头"><a href="#设置行列数据和表头" class="headerlink" title="设置行列数据和表头"></a>设置行列数据和表头</h2><p>必需一开始就设置好行/列数据和表头相关信息</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ui-&gt;tableWidget-&gt;setRowCount(<span class="number">10</span>);</span><br><span class="line">ui-&gt;tableWidget-&gt;setColumnCount(<span class="number">4</span>);</span><br><span class="line">ui-&gt;tableWidget-&gt;setHorizontalHeaderLabels(lables);</span><br></pre></td></tr></table></figure>
<h2 id="常用的一些设置"><a href="#常用的一些设置" class="headerlink" title="常用的一些设置"></a>常用的一些设置</h2><h3 id="不可编辑"><a href="#不可编辑" class="headerlink" title="不可编辑"></a>不可编辑</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ui-&gt;tableWidget-&gt;setEditTriggers(QAbstractItemView::NoEditTriggers);</span><br></pre></td></tr></table></figure>
<h3 id="单行选中"><a href="#单行选中" class="headerlink" title="单行选中"></a>单行选中</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QTreeWidgetItem* root = <span class="keyword">new</span> QTreeWidgetItem(QStringList() &lt;&lt; QStringLiteral(<span class="string">"广州模拟规约转换"</span>));</span><br><span class="line">ui-&gt;tableWidget-&gt;setSelectionBehavior(QAbstractItemView::SelectRows);<span class="comment">//设置选中模式为选中行</span></span><br></pre></td></tr></table></figure>
<h3 id="设置单元格为其它控件"><a href="#设置单元格为其它控件" class="headerlink" title="设置单元格为其它控件"></a>设置单元格为其它控件</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ui-&gt;tableWidget-&gt;setCellWidget(row, <span class="number">0</span>, pBtn);</span><br></pre></td></tr></table></figure>


<h1 id="事件响应"><a href="#事件响应" class="headerlink" title="事件响应"></a>事件响应</h1><h2 id="使用右键菜单"><a href="#使用右键菜单" class="headerlink" title="使用右键菜单"></a>使用右键菜单</h2><h2 id="按钮点击"><a href="#按钮点击" class="headerlink" title="按钮点击"></a>按钮点击</h2><p>这个不难，查找文档找到点击信号，然后建立起相应的连接即可。信号参数中已经指明了点击的Item和colum。</p>
<h1 id="数据相关"><a href="#数据相关" class="headerlink" title="数据相关"></a>数据相关</h1><h2 id="基础数据"><a href="#基础数据" class="headerlink" title="基础数据"></a>基础数据</h2><h3 id="设置值"><a href="#设置值" class="headerlink" title="设置值"></a>设置值</h3><p>单元格里还没有设置Item时，要先new一个Item出来，相关的值直接在构造函数中传递进去即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ui-&gt;tableWidget-&gt;setItem(row, <span class="number">1</span>, <span class="keyword">new</span> QTableWidgetItem(QString::number(selectId)));</span><br></pre></td></tr></table></figure>
<p>当单元格已经有值了，只是需要更新数据时，也只需要得到Item，然后setText即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ui-&gt;tableWidget-&gt;item(row, 2)-&gt;setText(&quot;100&quot;);</span><br></pre></td></tr></table></figure>
<p>但某个Item需要关联更多的数据的时候，可以使用QtUserRole来保存。</p>
<h3 id="取值"><a href="#取值" class="headerlink" title="取值"></a>取值</h3><p>得到想要的数据，首先就是要得到相应的Item指针。然后就很简单了，参考如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ui-&gt;tableWidget-&gt;item(<span class="number">0</span>, <span class="number">2</span>)-&gt;text().toInt();</span><br></pre></td></tr></table></figure>
<p> 最基础的相关数据包括，父节点，在父节点中的序号（第几个字节节点），节点文字的类型，节点的类型等等。很多时候，有这些数据就行了。</p>
<h2 id="附加自定义数据"><a href="#附加自定义数据" class="headerlink" title="附加自定义数据"></a>附加自定义数据</h2><p>当我们需要在QTableWidgetItem上关联较为复杂的数据时，可以利用QtUserRole域来保存QVarient数据的特性，如下是保存和取数据的代码参考：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">item-&gt;setData(Qt::UserRole + <span class="number">1</span>, QVariant::fromValue(data));</span><br><span class="line">QVariant var = item-&gt;data(Qt::UserRole + <span class="number">1</span>);</span><br><span class="line">TreeDeviceNodeAttachData deviceData = var.value&lt;TreeDeviceNodeAttachData&gt;();</span><br></pre></td></tr></table></figure>

<p>如果在Table中插入了很多其他控件，比如第1列有10个QPushButton，再点击按钮时如何识别到底是哪一个按钮点击了？有如下几种思路：</p>
<ol>
<li>想办法得到点击的坐标，然后根据坐标查找到QTableWidgetItem，然后就能知道是哪一个按钮点击了。</li>
<li>在插入button时，给每一个取一个唯一的name，名字部分携带相关信息，然后在点击响应槽中利用元数据信息得到事件源的name，然后得到信息。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QPushButton *senderObj = qobject_cast&lt;QPushButton*&gt;(sender());</span><br><span class="line"><span class="keyword">if</span>(senderObj == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QString name = sender()-&gt;objectName();</span><br><span class="line"><span class="keyword">int</span> row = name.mid(name.indexOf(<span class="string">"_"</span>) + <span class="number">1</span>).toInt();</span><br></pre></td></tr></table></figure></li>
<li>利用Item的QtUserRole保存额外信息的特性。</li>
</ol>
]]></content>
      <categories>
        <category>QT</category>
      </categories>
      <tags>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title>使用QTreeWidget</title>
    <url>/2019/08/16/QT/%E4%BD%BF%E7%94%A8QTreeWidget/</url>
    <content><![CDATA[<p>记录我使用过的一些特性 </p>
<h1 id="基本设置"><a href="#基本设置" class="headerlink" title="基本设置"></a>基本设置</h1><h2 id="设置列数和列的表头"><a href="#设置列数和列的表头" class="headerlink" title="设置列数和列的表头"></a>设置列数和列的表头</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ui-&gt;treeWidget-&gt;setColumnCount(<span class="number">1</span>);</span><br><span class="line">ui-&gt;treeWidget-&gt;setHeaderLabel(<span class="string">""</span>); <span class="comment">// 多个列的话用QStringList</span></span><br></pre></td></tr></table></figure>
<h2 id="设置顶层元素"><a href="#设置顶层元素" class="headerlink" title="设置顶层元素"></a>设置顶层元素</h2><p>顶层元素可以多个</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QTreeWidgetItem* root = <span class="keyword">new</span> QTreeWidgetItem(QStringList() &lt;&lt; QStringLiteral(<span class="string">"广州模拟规约转换"</span>));</span><br><span class="line">ui-&gt;treeWidget-&gt;addTopLevelItem(root); <span class="comment">// 多个元素的话，放到QList中，然后一次性添加进去</span></span><br></pre></td></tr></table></figure>
<h2 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h2><p>表示节点的类是QTreeWidgetItem，使用QStringList可以同时设置多列的值。在new 出来Item后，还需要添加到某个节点下作为其子节点</p>
<h1 id="事件响应"><a href="#事件响应" class="headerlink" title="事件响应"></a>事件响应</h1><h2 id="使用右键菜单"><a href="#使用右键菜单" class="headerlink" title="使用右键菜单"></a>使用右键菜单</h2><p>首先要使能右键弹出菜单功能</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ui-&gt;treeWidget-&gt;setContextMenuPolicy(Qt::CustomContextMenu);</span><br></pre></td></tr></table></figure>
<p>然后利用customContextMenuRequested信号，创建相应的槽函数来响应右键。在响应代码中创建Menu，然后弹出Menu即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MainWindow::on_treeWidget_customContextMenuRequested</span><span class="params">(<span class="keyword">const</span> QPoint &amp;pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QTreeWidgetItem * it = ui-&gt;treeWidget-&gt;itemAt(pos);</span><br><span class="line">    <span class="keyword">if</span>(!it)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    TreeItemLevel level = <span class="keyword">static_cast</span>&lt;TreeItemLevel&gt;(it-&gt;data(<span class="number">0</span>, Qt::UserRole).toInt());</span><br><span class="line">    <span class="keyword">if</span>(level == LevelChannel)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">QMenu <span class="title">menu</span><span class="params">(ui-&gt;treeWidget)</span></span>;</span><br><span class="line">        menu.addAction(_pChannelNewDevice);</span><br><span class="line">        menu.exec(QCursor::pos());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(LevelDevice == level)</span><br><span class="line">    &#123;</span><br><span class="line">        QMenu menu(ui-&gt;treeWidget);</span><br><span class="line">        menu.addAction(_pDeviceCopy);</span><br><span class="line">        menu.addAction(_pDeviceDelete);</span><br><span class="line">        menu.exec(QCursor::pos());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="按钮点击"><a href="#按钮点击" class="headerlink" title="按钮点击"></a>按钮点击</h2><p>这个不难，查找文档找到点击信号，然后建立起相应的连接即可。信号参数中已经指明了点击的Item和colum。</p>
<h1 id="数据相关"><a href="#数据相关" class="headerlink" title="数据相关"></a>数据相关</h1><h2 id="基础数据"><a href="#基础数据" class="headerlink" title="基础数据"></a>基础数据</h2><p>得到想要的数据，首先就是要得到相应的Item指针。左键点击得到对应的Item比较容易，右键点击要想知道当前点击的Item要较为麻烦点。使用如下的方法可行：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QTreeWidgetItem * it = ui-&gt;treeWidget-&gt;itemAt(pos);</span><br></pre></td></tr></table></figure>
<p> 最基础的相关数据包括，父节点，在父节点中的序号（第几个字节节点），节点文字的类型，节点的类型等等。很多时候，有这些数据就行了。</p>
<h2 id="附加自定义数据"><a href="#附加自定义数据" class="headerlink" title="附加自定义数据"></a>附加自定义数据</h2><p>当我们需要在TreeItem上关联较为复杂的数据时，可以利用QtUserRole域来保存QVarient数据的特性，如下是保存和取数据的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">device-&gt;setData(<span class="number">0</span>, Qt::UserRole + <span class="number">1</span>, QVariant::fromValue(data));</span><br><span class="line">QVariant var = item-&gt;data(<span class="number">0</span>, Qt::UserRole + <span class="number">1</span>);</span><br><span class="line">TreeDeviceNodeAttachData deviceData = var.value&lt;TreeDeviceNodeAttachData&gt;();</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>QT</category>
      </categories>
      <tags>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title>使用QJson</title>
    <url>/2019/08/16/QT/%E4%BD%BF%E7%94%A8QJson/</url>
    <content><![CDATA[<p>操作JSON文档总结。</p>
<h1 id="核心类介绍"><a href="#核心类介绍" class="headerlink" title="核心类介绍"></a>核心类介绍</h1><h2 id="QJsonDocument"><a href="#QJsonDocument" class="headerlink" title="QJsonDocument"></a>QJsonDocument</h2><p>表示一段JSON数据，数据的来源不由Document负责，可以是来自文件，可以是来自一段内存数据，可以QVariant变量，它仅仅是表示一段JSON数据而已。它提供了fromJson接口从内存、QVariant对象中解析得到JSON数据，也可以将自身的数据利用toJson转换一段字节序、QVariant对象。</p>
<h2 id="QJsonObject-amp-amp-QJsonArray"><a href="#QJsonObject-amp-amp-QJsonArray" class="headerlink" title="QJsonObject &amp;&amp; QJsonArray"></a>QJsonObject &amp;&amp; QJsonArray</h2><p>QJsonObject表示一个JSON数据对象，类似于一个Map，有键和值的概念，也可以使用迭代器进行遍历。QJsonArray表示一个数组类型的JSON对象，类似于QList。这两个都是json里面的基本概念，他们可以嵌套使用。</p>
<h2 id="QJsonValue"><a href="#QJsonValue" class="headerlink" title="QJsonValue"></a>QJsonValue</h2><h2 id="QJsonParseError"><a href="#QJsonParseError" class="headerlink" title="QJsonParseError"></a>QJsonParseError</h2>]]></content>
      <categories>
        <category>QT</category>
      </categories>
      <tags>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title>C++流及文件操作</title>
    <url>/2018/06/17/cpp/C++%E6%B5%81%E5%8F%8A%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>C++中引入了流了概念，相对C中对文件操作的函数，流是更加高层级的一个概念，这在JAVA等语言中主要是通过流来对文件进行操作。流就相当于一个管道，管道的另外一端连接一个具体的文件或者其它资源，通过流向其中写入数据就相当于把输入写入到资源中了，向流中取数据，就相当于从资源读取到数据了。这样，我们在操作资源时，面对的仅仅是流这么一个简单的概念，不再需要去关注具体的资源。假如流的一端是关联一个文件，操作流就相当于读写文件了。假如流的另一端关联的是字符串，操作流就相当于读写字符串了。甚至，可以将流关联到一个socket中，操作流就相当于通过socket读取和发送数据了。因为流的接口使用很简单，又统一，很多时候我们只需要将与具体资源的交互封装起来，再使用时就方便很多了。另外，基于流这么一个概念，以及流是一个一个处理数据的逻辑，多个流可以串联起来，实现很多扩展功能，比如处理文件的换行符，统计文件字数，编码转换，压缩与解压缩等等功能。</p>
<a id="more"></a>

<h1 id="C-标准库中流的组成"><a href="#C-标准库中流的组成" class="headerlink" title="C++标准库中流的组成"></a>C++标准库中流的组成</h1><p>不管概念上怎么说，流本质上还是一种操作资源的方法，始终还是无法避免直接操作资源。但是，<code>C++</code>标准库在设计的时候，对于资源的操作和对于流状态、控制信息的维护这两个工作是分开的，这样的设计能够使得逻辑更加清晰，更加易于扩展和维护。在C++标准库中，负责维护流状态的工作是iostream、fstream等流类，我们直接操作的也是这些接口。负责与资源打交道的是流类隐藏的buf类，有filebuf、stringbuf、streambuf等。实际上我们在自定义流的时候，一个很大部分的工作就是在自定义流buf。</p>
<h2 id="标准库中流相关类如下："><a href="#标准库中流相关类如下：" class="headerlink" title="标准库中流相关类如下："></a>标准库中流相关类如下：</h2><ul>
<li>ios_base: 封装了C++标准中的流，定义了在输入输出中不依赖于读写的数据类型的基本信息和行为，如格式化信息、异常状态、事件回调等。</li>
<li>ios: 所有流的基类，<code>base_ios&lt;char&gt;</code>的typedef。</li>
<li>istream/ostream/iostream :  提供&gt;&gt;操作符的功能，从缓冲区中提供目标值。提供&lt;&lt;操作符的功能，&lt;&lt;操作符在输出数据时会根据格式化控制信息格式化要输出的数据。</li>
<li>fstream/ifstream/ofstream： 对文件操作的类。</li>
<li>stringstream/istringstream/ostringstream ： 对字符串操作的类</li>
<li>streambuf/filebuf/stringbuf： 上述几种流的内部buf类。</li>
</ul>
<h1 id="流的操作"><a href="#流的操作" class="headerlink" title="流的操作"></a>流的操作</h1><p>除了能通过<code>&gt;&gt;</code>和<code>&lt;&lt;</code>来对流进行操作之外，标准库的流也提供类似与对资源的直接读/写大块二进制的操作。支持的有：<code>read</code>、<code>write</code>、<code>tellg</code>、<code>tellp</code>、<code>seekg</code>、<code>get</code>、<code>getline</code>、<code>fail</code>、<code>good</code>、<code>flush</code>、<code>ignore</code>、<code>bad</code>。</p>
<h1 id="自定义流"><a href="#自定义流" class="headerlink" title="自定义流"></a>自定义流</h1><p>标准库的tream对象的所有操作最终都委托给了内部的buf，对stream的对象的读写操作都是对buf的状态的改变。buf里面维护了多个指针用来辅助读写。在通过stream读写时，buf内部的状态会改变，会在适当的时候自动从资源读或者写操作。</p>
<p>自定义流，其实大部分是自定义buf管理对象。在标准库的各种资源管理buf中，主要是overflow、underflow、sync这么几个函数会与实际的文件进行交互，因此自定义资源管理buf主要也是重写这些会与实际资源交互的函数。</p>
<h1 id="Poco中流相关接口"><a href="#Poco中流相关接口" class="headerlink" title="Poco中流相关接口"></a>Poco中流相关接口</h1><table>
<thead>
<tr>
<th>类</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>BasicUnbufferdStreamBuf</td>
<td>继承自streambuf，Poco自定义buf的基类</td>
</tr>
<tr>
<td>BasicBufferedStreamBuf</td>
<td>继承自streambuf，Poco自定义buf的基类</td>
</tr>
<tr>
<td>BasicBufferedBidirectionalStreamBuf</td>
<td>继承自streambuf，Poco自定义buf的基类</td>
</tr>
<tr>
<td>***IOS</td>
<td>各种流的操作接口，虚拟继承自std::ios</td>
</tr>
<tr>
<td>Base32Decoder</td>
<td>Base32解密流</td>
</tr>
<tr>
<td>Base32Encoder</td>
<td>Base32加密流</td>
</tr>
<tr>
<td>Base64Decoder</td>
<td>Base64解密流</td>
</tr>
<tr>
<td>Base64Encoder</td>
<td>Base64加密流</td>
</tr>
<tr>
<td>CountingOutputStream</td>
<td>继承自CountingIOS和ostream的计数流</td>
</tr>
<tr>
<td>CountingInputStream</td>
<td>继承自CountingIOS和istream的计数流</td>
</tr>
<tr>
<td>DeflatingInputStream</td>
<td>继承自DeflatingIOS和istream的压缩流</td>
</tr>
<tr>
<td>DeflatingOutputStream</td>
<td>继承自DeflatingIOS和ostream的解压流</td>
</tr>
<tr>
<td>InflatingInputStream</td>
<td>继承自InflatingIOS和istream的压缩流</td>
</tr>
<tr>
<td>InflatingOutputStream</td>
<td>继承自InflatingIOS和ostream的解压流</td>
</tr>
<tr>
<td>HexBinaryDecoder</td>
<td></td>
</tr>
<tr>
<td>HexBinaryEncoder</td>
<td></td>
</tr>
<tr>
<td>OutputLineEndingConverter</td>
<td>行尾符号转换输出流</td>
</tr>
<tr>
<td>InputLineEndingConverter</td>
<td>行尾符号转换输入流</td>
</tr>
<tr>
<td>TeeOutputStream</td>
<td></td>
</tr>
<tr>
<td>FileInputStream</td>
<td>文件操作输入流</td>
</tr>
<tr>
<td>FileOutputStream</td>
<td>文件操作输出流</td>
</tr>
<tr>
<td>MemoryOutputStream</td>
<td>内存操作输出流</td>
</tr>
<tr>
<td>MemoryInputStream</td>
<td>内存操作输入流</td>
</tr>
<tr>
<td>BinaryWriter</td>
<td>写7bit编码的二进制文件</td>
</tr>
<tr>
<td>BinaryReader</td>
<td>读7bit编码的二进制文件</td>
</tr>
<tr>
<td>StreamCopier</td>
<td>流赋值，用于连接2个流的工具类</td>
</tr>
<tr>
<td>StreamTokenizer</td>
<td></td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>基础，Poco</tag>
      </tags>
  </entry>
  <entry>
    <title>string和wstring探秘</title>
    <url>/2018/06/09/cpp/blog_string%E5%92%8Cwstring%E6%8E%A2%E7%A7%98/</url>
    <content><![CDATA[<p>在使用std::string 和 std::wstring 时，总有一些问题困恼着我：<br>    1. std::string 为什么会存在字符串乱码的问题?<br>    2. std::string 和 std::wstring 的却别到底是什么？<br>    3. std::string 中使用中文一定会乱码码？<br>    4. std::string 和 std::wstring 内部二进制是怎么样？<br>    5. windows和Linux下的std::string和std::wstring 表示是一致的吗？</p>
<a id="more"></a>

<h1 id="std-string"><a href="#std-string" class="headerlink" title="std::string"></a>std::string</h1><p>std::string 内部使用char来存储数据。因此，编译器在遇到std::string变量时，总是一个字节一个字节的去处理。但是编译器将源码中的字符串转成特定的编码的一串二进制字节的方法由平台不同而不同。</p>
<h2 id="windows下std-string的处理"><a href="#windows下std-string的处理" class="headerlink" title="windows下std::string的处理"></a>windows下std::string的处理</h2><p>在Windows平台上，string会将源码字符串转成ANSI编码方案中的二进制码。所以你在用VS调试时，查看string时，显示的内容也是按照ANSI方案编码解析出来的。假如源码是UTF-8的，则会进行UTF-8到ANSI的转换。假如源码是GBK的，则会进行GBK到ANSI的转换。</p>
<h2 id="Linux下的std-string的处理"><a href="#Linux下的std-string的处理" class="headerlink" title="Linux下的std::string的处理"></a>Linux下的std::string的处理</h2><p>在Linux平台上，string不会处理源码文件中的二进制码,假如文件时UTF-8格式的，则string中存储的中文字符也是UTF-8格式的。假如源文件是GBK的，则string中存储的中文字符也是GBK的。因此，在linux上，我们只要保证源码是UTF-8的格式的，就能保证在所有的地方显示正常了。</p>
<p>因此，对于在中文地区使用的电脑来说，给std::string赋值中文字符串时，到底会不会乱码，这需要根据你采用的平台和源码的保存格式了。因为ANSI是一个编码方案，不对应到具体的编码规则，在不同地区的电脑上，ANSI所代表的编码方案是不一样的。在中文地区，所有的字符串都编码成了GBK，如果将程序拷贝到其它地区的电脑，执行时系统会将字符串解释成对应的本地代码页对应的字符，这样肯定会造成乱码。因此为了编写的程序为了能在全球通用，在WINDOWS上开发时，建议使用Unicode编码方案。但是在Linux上不一样，只要我们是使用的UTF-8来保存源码，则不存在在全球不通用的问题。</p>
<h1 id="std-wstring"><a href="#std-wstring" class="headerlink" title="std::wstring"></a>std::wstring</h1><p>std::wstring 被设计用来存储任意的字符，在编译读取到字符串字面量之后(比如L”hello”)，将进行转换处理，将源码中字符串对应的二进制转成unicode方案的UTF-16编码对应的二进制。在windows上每wchar字符都使用2个字节来存储，因此只能使用UCS-2编码字符表的内容。使用到std::wstring的库也都会将wstring按照UTF-16来解析，由于UTF-16对UCS-2是一一对应的，因此编译后的程序只要在支持Unicode的计算机上运行，都不会有乱码的烦恼。但是注意在Linux上，wchar_t是4个字节的。</p>
<h1 id="使用建议"><a href="#使用建议" class="headerlink" title="使用建议"></a>使用建议</h1><ol>
<li>在Linux平台上，不需要用到wstring，只需要用到string</li>
<li>在windows平台上，最好使用wstring</li>
<li>跨平台代码就自己想办法吧</li>
</ol>
<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>使用如下的代码可以用来测试上面所说得情况，将源码保存成不同的格式（UTF-8、GBK等)后编译运行，查看结果。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> text[] = <span class="string">"我是中国人"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(char)    : "</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">char</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"text            : "</span> &lt;&lt; text &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(text)    : "</span> &lt;&lt; <span class="keyword">sizeof</span>(text) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"strlen(text)    : "</span> &lt;&lt; <span class="built_in">strlen</span>(text) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"text(bytes)     :"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>, iMax = <span class="built_in">strlen</span>(text); i &lt; iMax; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::hex &lt;&lt; <span class="string">" 0x"</span> &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt;(</span><br><span class="line">            <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt;(text[i])</span><br><span class="line">            );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">wchar_t</span> wtext[] = <span class="string">L"我是中国人"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(wchar_t) : "</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">wchar_t</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::wcout &lt;&lt; <span class="string">L"wtext           : "</span> &lt;&lt; wtext &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(wtext)   : "</span> &lt;&lt; <span class="keyword">sizeof</span>(wtext) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"wcslen(wtext)   : "</span> &lt;&lt; wcslen(wtext) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"wtext(bytes)    :"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>, iMax = wcslen(wtext); i &lt; iMax; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;  <span class="built_in">std</span>::hex &lt;&lt; <span class="string">" 0x"</span> &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt;(</span><br><span class="line">            <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> short&gt;(wtext[i])</span><br><span class="line">            );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="https://unicode-table.com/cn/" target="_blank" rel="noopener">unicode字符表</a></li>
<li><a href="http://www.qqxiuzi.cn/bianma/zifuji.php" target="_blank" rel="noopener">中文汉字编码查询</a></li>
<li><a href="https://stackoverflow.com/questions/402283/stdwstring-vs-stdstring" target="_blank" rel="noopener">stackoverflow: string vs wstring</a></li>
</ol>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>智能指针总结</title>
    <url>/2018/06/07/cpp/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>对于C++来说，智能指针是一种很有用的技术，能够帮助我们更好的管理内存，当然我们也需要对智能指针的原理及实现进行较为深入的理解才能避免带来的负面影响。</p>
<a id="more"></a>

<h1 id="指针的几个经典的使用场景"><a href="#指针的几个经典的使用场景" class="headerlink" title="指针的几个经典的使用场景"></a>指针的几个经典的使用场景</h1><p>智能指针最根本的需求就是解放我们手动释放内存的需求，使用时，只需要申请，而无需理会。但是在不同的场景下，正确的实现和使用却不是那么容易。从使用目的的角度，总结的来说只有2种：</p>
<ol>
<li>简答的管理资源，避免遗忘，自动释放。</li>
<li>涉及到复制场景，函数传参、容器内使用等等。</li>
</ol>
<p>针对指针的所有权来说，指针又可以分为两类：</p>
<ol>
<li>某一个时间，只有一个智能指针能访问到对象。</li>
<li>某一个时间，允许多个指针指针指向同一个对象（某个的权限不一样，但是能访问到）</li>
</ol>
<h1 id="指针智能的分类"><a href="#指针智能的分类" class="headerlink" title="指针智能的分类"></a>指针智能的分类</h1><p>早期为了实现资源的自动释放而出现了智能指针，因此出现了<code>auto_ptr</code>。但是由于没有采用引用计数，无法智能的自动删除对象。没有采用引用计数就只能在构造和析构函数中创建和释放内存，在存在赋值或者拷贝时，为了避免两个指针同时指向一个对象的现象，其实现时在赋值和拷贝构造函数中中采用转移了指针的所有权的策略，导致赋值或者拷贝前的<code>auto_ptr</code>为NULL，而且这个不可用在编译时无法检查，因此给使用auto_ptr造成了很多限制。这种智能指针无法用在函数参数,STL容器等地方，因此不建议使用这种智能指针。C++14已经明确不支持。</p>
<p>下面我梳理的几种指针智能都不是传统标准库的auto_ptr这种特性的指针。</p>
<h2 id="std-unique-ptr"><a href="#std-unique-ptr" class="headerlink" title="std::unique_ptr"></a>std::unique_ptr</h2><p>相当于boost库的<code>scope_ptr</code>。相比于<code>auto_ptr</code>中存在的问题，std::unique_ptr则是其一个很好的解决方法，unique_ptr只允许一时间只有一个对象拥有目标对象，它从编译时就能检测到赋值和拷贝动作，从而对我们进行提示。很多时候，我们仅仅时需要一个智能智能来管理资源，我们不需要它被拷贝。</p>
<p>但是需要注意的是，从函数中返回内部的unique_ptr是允许的，虽然这也涉及到拷贝。从业务逻辑上，这时候的拷贝和通常的拷贝目的是有差别的。unique_ptr也可以实在STL容器中，但是不能使用容器的可能触发赋值和拷贝的算法。</p>
<h2 id="std-shared-ptr"><a href="#std-shared-ptr" class="headerlink" title="std::shared_ptr"></a>std::shared_ptr</h2><p>采用引用计数实现的智能指针，这个就是我们通常意义上的普通智能指针。正如其名，shared意味着多个智能指针共享同一个对象。可以正常使用在函数，STL容器等地方。需要注意的时，reset方法需要慎重使用。</p>
<p>reset()包含两个操作。当智能指针中有值的时候，调用reset()会使引用计数减1.当调用reset（new xxx())重新赋值时，智能指针首先是生成新对象，然后将旧对象的引用计数减1（当然，如果发现引用计数为0时，则析构旧对象），然后将新对象的指针交给智能指针保管</p>
<h2 id="std-weak-ptr"><a href="#std-weak-ptr" class="headerlink" title="std::weak_ptr"></a>std::weak_ptr</h2><p>std::shared_ptr在使用时有一个陷阱：可能造成循环引用。解决这个问题的方法是就是采用std::weak_ptr。std::weak_ptr申明一个智能对象用来观察原有指针，它的拷贝、赋值等操作不会导致引用增加。但是一旦你需要使用指针的内容时，必须先通过weak_ptr.lock()取得一个shared_ptr对象，否则无法使用内容。</p>
<h1 id="使用时的注意事项"><a href="#使用时的注意事项" class="headerlink" title="使用时的注意事项"></a>使用时的注意事项</h1><ol>
<li>不要用一个原始指针初始化多个shared_ptr，原因在于，会造成二次销毁。</li>
<li>不要在函数实参中创建shared_ptr。因为C++的函数参数的计算顺序在不同的编译器下是不同的。正确的做法是先创建好，然后再传入。</li>
<li>禁止通过shared_from_this()返回this指针，这样做可能也会造成二次析构。</li>
<li>使用shared_ptr共享资源时，我们有责任保证这些资源时线程安全的。</li>
<li>不适用auto_ptr。</li>
<li>建议使用make_shared来初始化shared_ptr。</li>
<li>在创建一个对象（裸指针）时没有立即把它赋给shared_ptr。</li>
<li>删掉被shared_ptr使用的裸指针。</li>
<li>当使用一个shared_ptr指向指针数组时没有使用自定义的删除方法.</li>
<li>没有删除通过unique_ptr.release()返回的裸指针, 调用Release后unique_ptr则从销毁对象的责任中解脱出来。</li>
<li>在调用weak_ptr.lock()的时候没检查它的有效性.</li>
</ol>
<h1 id="智能指针的选择"><a href="#智能指针的选择" class="headerlink" title="智能指针的选择"></a>智能指针的选择</h1><p>如果程序要使用多个指向同一个对象的指针，应选择shared_ptr。这样的情况包括：</p>
<ul>
<li>有一个指针数组，并使用一些辅助指针来标示特定的元素，如最大的元素和最小的元素；</li>
<li>两个对象包含都指向第三个对象的指针， 类中指针第三者对象使用shared_ptr；</li>
<li>STL容器包含指针。很多STL算法都支持复制和赋值操作，这些操作可用于shared_ptr，但不能用于unique_ptr（编译器发出warning）和auto_ptr（行为不确定）。</li>
</ul>
<p>逻辑上真的需要使用独有的资源(对象)时，使用unique_ptr，包括：</p>
<ul>
<li>如果程序不需要多个指向同一个对象的指针，这种情况通常用在局部的代码中，则可使用unique_ptr。</li>
<li>如果函数使用new分配内存，并返还指向该内存的指针， 将其返回类型声明为unique_ptr是不错的选择。</li>
<li>默认情况下使用unique_ptr，如确实有需要再考虑其它。</li>
</ul>
<h1 id="Poco库中的智能指针"><a href="#Poco库中的智能指针" class="headerlink" title="Poco库中的智能指针"></a>Poco库中的智能指针</h1><h2 id="SharedPtr"><a href="#SharedPtr" class="headerlink" title="SharedPtr"></a>SharedPtr</h2><p>Poco::SharedPtr则与std::shared_ptr相似，实现原理，行为也是差不多的。</p>
<h2 id="AutoPtr"><a href="#AutoPtr" class="headerlink" title="AutoPtr"></a>AutoPtr</h2><p>Poco库的AutoPtr与标准库的指针有很大的不同，Poco::AutoPtr实现了一个能够实例化任何支持引用计数对象的类。最简单的支持引用计数的类就是继承自RefCountedObject，另外符合下列要求的类可以被定义成为支持引用计数：</p>
<ol>
<li>这个类必须存在引用计数，在对象被创建时，引用计数被初始化值为1</li>
<li>这个类必须支持duplicate()接口增加引用计数</li>
<li>这个类必须支持release()接口减少引用计数，并且在引用计数为0时，删除类对象。</li>
</ol>
<p>Poco::AutoPtr与标准库智能指针的指针最大的不同就是保存引用计数的地方不同，标准库各个智能指针对象是独立的，其各自维护一份对目标对象的引用计数。因此如果一个原始指针赋值给多个智能指针所导致的重复释放问题是没办法解决。AutoPtr的应用计数维持在所管理的对象中，而不是AutoPtr对象中。因此AutoPtr虽然不建议将一个对象指针给多个AutoPtr对象，但是提供方法来处理这种情况。方法就是在构造或者赋值的时候传递shared为true的标志。</p>
<p>AutoPtr是比std::shared_ptr更加智能更加灵活的实现，语义上std::shared_ptr能做到的，AutoPtr都能做到。也是可以使用在STL的容器中，函数返回时，可以直接返回AutoPtr。唯一的问题就是：AutoPtr对所管理的对象比较挑剔，必须要所管理的对象自己管理自己的引用计数。</p>
<p>AutoPtr相关特性如下：</p>
<ol>
<li>构造函数，不会触发管理的对象的计数器变化，除非使用shared标志。</li>
<li>拷贝构造函数，因为拷贝构造函数的语义就是将对象拷贝给另一个同类对象，因此计数器必须加1</li>
<li>赋值操作符，这个语义是：<ul>
<li>如果原来无对象，自然不会有任何意外的结果</li>
<li>如果原来有管理对象，需要首先对原有对象的计数器减1。    </li>
<li>新对象如果是原始指针，则不需要对计数器处理，除非有shared标志</li>
<li>新对象如果是AutoPtr，自然需要对新的对象的计数器加1</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>C++</category>
        <category>Poco</category>
      </categories>
      <tags>
        <tag>智能指针</tag>
      </tags>
  </entry>
  <entry>
    <title>git常用命令</title>
    <url>/2019/04/09/git/git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>Git的配置分为三级：</p>
<ol>
<li>第一级是系统级，即本机上所有用户所有仓库都生效的配置，对应配置文件路径是/etc/gitconfig，或者是安装目录下的etc/gitconfig文件。如果传递–system选项给git config命令， Git 会读写这个文件。</li>
<li>第二级是全局级，是本机当前用户的全部配置，对应配置文件路径~/.gitconfig文件，如果传递–global选项给git config命令， Git 会读写这个文件。</li>
<li>最后一级是项目级，只对本项目有效，对应仓库目录下的.git/config，不加任何选项的git config读写的这个文件。</li>
</ol>
<p>以上阐述的三层配置从一般到特殊层层推进，如果定义的值有冲突，以后面层中定义的为准，例如：在.git/config和/etc/gitconfig的较量中， .git/config取得了胜利</p>
<h2 id="设置名字和邮箱地址"><a href="#设置名字和邮箱地址" class="headerlink" title="设置名字和邮箱地址"></a>设置名字和邮箱地址</h2><p>git config –global user.name “Reliy”<br>git config –global user.email <a href="mailto:stu_reliy@163.com">stu_reliy@163.com</a></p>
<h2 id="生成ssh-key"><a href="#生成ssh-key" class="headerlink" title="生成ssh key"></a>生成ssh key</h2><p>ssh-keygen -t rsa -C ‘xxxxx@company.com’ -f ~/.ssh/gitee_id_rsa</p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><ul>
<li><code>git diff [file]</code> : 查看某个文件修改了那些内容</li>
<li><code>git checkout -- .</code> : 撤销工作区的修改</li>
<li><code>git checkout -- [file]</code> : 撤销工作区的某个文件修改</li>
<li><code>git reset  --hard HEAD^</code> : 回退到上一个版本</li>
<li><code>git reset  --hard HEAD~</code> : 回退到上一个版本</li>
<li><code>git reflog</code> : 查看本地的历史操作记录，取得操作id后，可以回到任何一个历史状态，包括git reset前的状态。历史记录的条数是有限的，数量可以配置。</li>
<li><code>git rm [file]</code> : 删除XX文件</li>
<li><code>git commit --amend</code> : 使用上次的提交注释重新提交，在某次提交发现有遗漏时用这个补救。</li>
<li><code>git pull --rebase</code> : </li>
<li><code>git push origin --delete &lt;remote-branchname&gt;</code></li>
</ul>
<h2 id="与远程库的交互"><a href="#与远程库的交互" class="headerlink" title="与远程库的交互"></a>与远程库的交互</h2><ul>
<li><code>git remote add origin [url]</code> : 添加一个远程仓库，origin表示远程仓库在本地的名称。</li>
<li><code>git push origin maste</code> : 把当前master分支推送到远程库  </li>
<li><code>git remote –v</code> : 查看远程库的详细信息</li>
</ul>
<h2 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h2><ul>
<li><code>git branch</code> : 查看当前所有的分支</li>
<li><code>git checkout –b dev</code> : 创建dev分支 并切换到dev分支上</li>
<li><code>git branch name</code> : 创建分支</li>
<li><code>git checkout [branch name]</code> : 切换到某个分支</li>
<li><code>git merge [branch name]</code> : 合并某个分支的内容到本分子，提交历史中有合并记录</li>
<li><code>git branch –d dev</code> : 删除dev分支</li>
</ul>
<h2 id="暂时保存"><a href="#暂时保存" class="headerlink" title="暂时保存"></a>暂时保存</h2><ul>
<li><code>git stash</code> : 把当前的工作隐藏起来 等以后恢复现场后继续工作</li>
<li><code>git stash list</code> :  查看所有被隐藏的文件列表</li>
<li><code>git stash apply</code> : 恢复被隐藏的文件，但是内容不删除</li>
<li><code>git stash drop</code> : 删除文件</li>
<li><code>git stash pop</code> : 恢复文件的同时 也删除文件</li>
</ul>
<h2 id="fetch命令使用"><a href="#fetch命令使用" class="headerlink" title="fetch命令使用"></a>fetch命令使用</h2><p>下载的代码对本地没有影响，命令格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git fetch &lt;远程主机名&gt; &lt;分支名&gt;</span><br><span class="line">git fetch origin master</span><br></pre></td></tr></table></figure>

<p>git fetch origin 等同于git fetch<br>会将全部分支都下载到本地，若是本地没有分支则会创建分支。</p>
<p>取回的更新，在本地主机上要用”远程主机名/分支名”的形式读取。比如origin主机的master，就要用origin/master读取。取回更新后，会返回一个FETCH_HEAD ，指的是某个branch在服务器上的最新状态，我们可以在本地通过它查看刚取回的更新信息。<br>git log -p FETCH_HEAD 可以查看服务器上的分支的内容。</p>
<h2 id="Merge"><a href="#Merge" class="headerlink" title="Merge"></a>Merge</h2><p>合并，可以合并本地的某个分支，也可以用来合并下载下来的服务器的某个分支。</p>
<p>git checkout master<br>git merge dev<br>以上是合并dev分支到当前分支（master分支）</p>
<p>git checkout dev<br>git merge master<br>以上是合并master分支到（dev分支）</p>
<p>git checkout master<br>git merge origin/master<br>fetch后可使用本命令来合并远程的内容到本地当前分支。merge并不会去服务器拉取内容来合并，因此必须要先fetch，使用本命令才能达到目的。</p>
<h2 id="Pull"><a href="#Pull" class="headerlink" title="Pull"></a>Pull</h2><p>pull等同于fetch和merge的过程，主要是简化了从服务器下载内容并合并到本地的过程。</p>
<p>终极命令是如下的部分，冒号后面的master是本地分支，意思是将服务器的master分支合并到本地的master分支。如有需要，可以选择服务器的任意分支和本地的任意分支合并。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git pull origin master:master</span><br></pre></td></tr></table></figure>
<p>如果要使用pull的话，建议使用<code>git pull --rebase</code>, 它等于以下两条命令。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git fetch</span><br><span class="line">git rebase origin&#x2F;master</span><br></pre></td></tr></table></figure>

<h2 id="Rebase"><a href="#Rebase" class="headerlink" title="Rebase"></a>Rebase</h2><p>分支合并的过程的过程中，如果2个分支的改动涉及到同一个文件，合并动作就无法自动的按照时间的先后顺序的进行进行合并。手动处理完冲突之后，也会产生一条合并的记录，用来告诉我们修改的历史涉及到多个分支的操作。</p>
<p>冲突的根本原因就是两个分支的共同祖先太早了，解决原理就是，将本地的分支2的提交历史进行修改，强制设置为冲突时候分支1的那次提交为父节点。冲突之前的肯定是能顺利的合并的，解决完冲突之后，分支2的本次提交内容就改变了，就能以分支1的最新提交为父节点了。这样，分支2就能顺利的合并了，整个提交历史就是线性的。</p>
<p>假设分支1有：A、B、C、D四次提交。分支2有：A、E、F三次提交，D、F两次提交有冲突。E、F是能轻易的追加到C之后的，因为没有冲突。强制修改F提交的内容后，E、F就能追加到D之后呢，分支2的整个历史就是A、B、C、D、E、F，提交或者合并到分支1时，从分支1上所看到的历史也就是线性的了。</p>
<p>上面的描述中有一个错误，并不是有冲突才会导致历史分叉，只要分支2在创建出来之后，分支1还在继续推进，就会导致分叉。具体将：<a href="http://gitbook.liuhui998.com/4_2.html" target="_blank" rel="noopener">http://gitbook.liuhui998.com/4_2.html</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Git rebase origin&#x2F;master</span><br><span class="line">将当前的分支以服务器仓库对应的为基准。</span><br><span class="line"></span><br><span class="line">Git rebase –continue</span><br><span class="line">Git rebase –abort</span><br></pre></td></tr></table></figure>

<p><strong>两个使用场景</strong></p>
<p>场景1，在push之前，先用fetch下载服务器的最新的内容，然后使用rebase命令修改本地的commit历史，使得本地的提交都是基于远程服务器的最新版本，使得接下来的push动作不会导致提交历史有分叉。</p>
<p>场景2，在本bug修改分支需要合并到主要开发分支时，用rebase变下基，再合并。</p>
<h2 id="使用纪律"><a href="#使用纪律" class="headerlink" title="使用纪律"></a>使用纪律</h2><p>首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活。</p>
<p>干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本；</p>
<ol>
<li>分支分为：master、dev、feature_xxx、bugfix_xxx几类</li>
<li>确认当前分支是否为即将工作的分支，如有需要请尽量创建分支来工作</li>
<li>切换到工作分支前确认当前分支是否需要提交或者暂存stash，然后切换到工作分支。</li>
<li>进入工作分支后，确认是否有stash的内容，如有请弹出。</li>
<li>工作，尽量多的提交次数。</li>
<li>当前工作分支工作完毕即将合并到dev分支前，使用rebase命令变基</li>
<li>切换到dev分支并合并掉前面的工作分支，删除工作分支。</li>
<li>即将推送前，使用fetch下载最新内容，然后使用rebase进行变基</li>
<li>推送</li>
</ol>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>nullptr使用</title>
    <url>/2019/07/12/cpp/nullptr%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>在c++11之前，表示空指针的方法都存在问题，虽然可以用NULL来表示，但问题也不少。<a id="more"></a> </p>
<h1 id="C的NULL"><a href="#C的NULL" class="headerlink" title="C的NULL"></a>C的NULL</h1><p>在C语言中，我们使用NULL表示空指针，也就是我们可以写如下代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *i = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">foo_t</span> *f = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
<p>实际上在C语言中，NULL通常被定义为如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NULL ((void *)0)</span></span><br></pre></td></tr></table></figure>
<p>也就是说NULL实际上是一个<code>void *</code>的指针，然后把<code>void *</code>指针赋值给<code>int *</code>和<code>foo_t *</code>的指针的时候，隐式转换成相应的类型。</p>
<h1 id="C-的NULL"><a href="#C-的NULL" class="headerlink" title="C++的NULL"></a>C++的NULL</h1><p>但是在<code>C++</code>编译器来编译的话是要出错的，因为<code>C++</code>是强类型的，<code>void *</code>是不能隐式转换成其他指针类型的，所以通常情况下，编译器提供的头文件会这样定义NULL：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NULL 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NULL ((void *)0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>因为<code>C++</code>中不能将<code>void *</code>类型的指针隐式转换成其他指针类型，而又为了解决空指针的问题，所以<code>C++</code>中引入0来表示空指针（注：0表示，还是有缺陷不完美），这样就有了类似上面的代码来定义NULL。实际上<code>C++</code>的书都会推荐说<code>C++</code>中更习惯使用0来表示空指针而不是<code>NULL</code>，尽管<code>NULL</code>在<code>C++</code>编译器下就是0。</p>
<p>假设有如下的函数定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">(sometype1 a, sometype2 *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">do</span> something...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">(sometype1 a, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">do</span> something...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在调用时，<code>bar(a, NULL)</code>这样的语句就可能造成逻辑上的问题，代码的本意是调用第一个函数，实际上是调用了第2个函数。因为NULL就是0，一个整型。 这个代码上的错误很容易忽略，因为NULL不够“明显”，而这里如果是使用0来表示空指针，那就会够“明显”，因为0是空指针，它更是一个整形常量。在<code>C++</code>中，使用0来做为空指针会比使用NULL来做空指针会让你更加警觉。</p>
<h1 id="C-11的nullptr"><a href="#C-11的nullptr" class="headerlink" title="C++ 11的nullptr"></a>C++ 11的nullptr</h1><p>上面我们说明了0比NULL可以让我们更加警觉，但是我们并没有避免这个问题。这个时候<code>C++ 11</code>的nullptr就很好的解决了这个问题，我们在<code>C++ 11</code>中使用nullptr来表示空指针。这样一切需要空指针的地方，我们都使用nullptr。</p>
<h1 id="混合使用场景的解决方案"><a href="#混合使用场景的解决方案" class="headerlink" title="混合使用场景的解决方案"></a>混合使用场景的解决方案</h1><p>新的代码中我们可以用nullptr来表示空指针，但是在维护老的代码时，我们可以将部分维护过的代码中NULL替换成nullptr吗？答案是肯定的。nullptr和NULL都表示逻辑上的空指针，只是NULL还有副作用而已。使用到空指针的地方基本上都是判断语句中，使用时如下的2种场景都是ok的。</p>
<p>场景一：先用NULL给指针赋值，然后用nullptr来判断，是ok的。比如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>* p = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"p is null\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>场景二：先用nullptr给指针赋值，然后用NULL来判断，是ok的，比如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>* p = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"p is null\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++11</tag>
      </tags>
  </entry>
  <entry>
    <title>git配置多个SSH key方案</title>
    <url>/2019/04/09/git/git-%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AASSH%20key/</url>
    <content><![CDATA[<p>当在一台电脑上有多个git账号时，对不同的仓库需要提及到不同的托管服务器时，有两种方案可以做到配置一次，然后提交时无需关心使用的key。比如：一个gitee，用于公司内部的工作开发；一个github，用于自己进行一些开发活动。</p>
<a id="more"></a> 

<h1 id="生成2个ssh-key"><a href="#生成2个ssh-key" class="headerlink" title="生成2个ssh key"></a>生成2个ssh key</h1><p>生成一个gitee用的SSH-Key</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &#39;xxxxx@company.com&#39; -f ~&#x2F;.ssh&#x2F;gitee_id_rsa</span><br></pre></td></tr></table></figure>
<p>生成一个github用的SSH-Key</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &#39;xxxxx@qq.com&#39; -f ~&#x2F;.ssh&#x2F;github_id_rsa</span><br></pre></td></tr></table></figure>

<h1 id="解决方案一"><a href="#解决方案一" class="headerlink" title="解决方案一"></a>解决方案一</h1><p>对于每个具体的项目，手动指定使用的ssh key文件。</p>
<h1 id="解决方案二"><a href="#解决方案二" class="headerlink" title="解决方案二"></a>解决方案二</h1><p>另外一种解决方案就是全局级别的识别。</p>
<p>git默认会去<del>/.ssh目录下查找相关key文件，因此我们只需要在.ssh目录下做些改动即可。在 `</del>/.ssh` 目录下新建一个config文件，添加如下内容（其中Host和HostName填写git服务器的域名，IdentityFile指定私钥的路径）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># gitee</span><br><span class="line">Host gitee.com</span><br><span class="line">HostName gitee.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~&#x2F;.ssh&#x2F;gitee_id_rsa</span><br><span class="line"># github</span><br><span class="line">Host github.com</span><br><span class="line">HostName github.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~&#x2F;.ssh&#x2F;github_id_rsa</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<pre><code>在Linux系统下需要特别注意config文件以及其它几个文件到权限，必须设置为600才行。</code></pre><p>用ssh命令分别测试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh -Tgit@gitee.com</span><br><span class="line">ssh -Tgit@github.com</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows开发环境配置</title>
    <url>/2019/06/02/%E5%85%B6%E5%AE%83/Windows%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><p>是</p>
]]></content>
      <categories>
        <category>Window</category>
      </categories>
  </entry>
  <entry>
    <title>Nmap使用</title>
    <url>/2020/05/15/%E5%85%B6%E5%AE%83/nmap%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>使用Nmap通常有两个目的，一个是发现网络内有多少主机正在开机运行，另外一个是发现主机有哪些端口提供服务。</p>
<h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><p>扫描特定主机的全部端口，看哪些端口提供服务。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nmap -sS -p 1-65535 -v 192.168.1.254</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>Nmap</tag>
      </tags>
  </entry>
  <entry>
    <title>cmake使用笔记</title>
    <url>/2018/05/20/%E5%85%B6%E5%AE%83/%E4%BD%BF%E7%94%A8CMake/</url>
    <content><![CDATA[<p>cmake对于C/C++程序员的重要性无需多言，记录下自己的理解。</p>
<a id="more"></a> 

<p>首先要明白，Cmake只是个生成各个平台的构建工程的工具，最终各个代码的构建还是要依靠各个平台的工具来编译生成，比如make、nmake、qmake等。<br>在下面的命令中，只要是指定路径的都必须是全路径，当然全路径可以通过相应的宏来拼凑出来.</p>
<h2 id="如何指定生成的目标文件：可执行文件、静态库、动态库。"><a href="#如何指定生成的目标文件：可执行文件、静态库、动态库。" class="headerlink" title="如何指定生成的目标文件：可执行文件、静态库、动态库。"></a>如何指定生成的目标文件：可执行文件、静态库、动态库。</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">add_executable(&lt;name&gt; [WIN32] [MACOSX_BUNDLE] [EXCLUDE_FROM_ALL]   source1 [source2 ...])</span><br><span class="line">add_library(&lt;name&gt; [STATIC | SHARED | MODULE]  [EXCLUDE_FROM_ALL]   source1 source2 ... sourceN)</span><br></pre></td></tr></table></figure>

<h2 id="如何添加连接所需要的库文件"><a href="#如何添加连接所需要的库文件" class="headerlink" title="如何添加连接所需要的库文件"></a>如何添加连接所需要的库文件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">link_directories(directory1 directory2 ...)</span><br></pre></td></tr></table></figure>
<p>制定连接库的查找目录，它相当于g++命令的-L选项的作用，也相当于环境变量中增加LD_LIBRARY_PATH的路径的作用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find_library (&lt;VAR&gt; name1 [path1 path2 ...])</span><br></pre></td></tr></table></figure>
<p>这里的效果也是查找库，只不过最终是路径添加到变量名中，不过也还是需要将得到的变量名传入<br><code>link_directories</code>中来设置查找目录。</p>
<p>添加制定的连接库文件有两种方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">link_libraries(library1 &lt;debug | optimized&gt; library2 ...)</span><br></pre></td></tr></table></figure>
<p>所有生成的目标都需要连接的库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">target_link_libraries(&lt;target&gt; [item1 [item2 [...]]]  [[debug|optimized|general] &lt;item&gt;] ...)</span><br></pre></td></tr></table></figure>
<p>特定目录需要特定连接的库对于所添加的具体文件的写法上可以有多种写法， 以下写法都可以： </p>
<ol>
<li><code>target_link_libraries(myProject comm) # 连接libhello.so库，默认优先链接动态库</code></li>
<li><code>target_link_libraries(myProject libcomm.a) # 显示指定链接静态库</code></li>
<li><code>target_link_libraries(myProject libcomm.so) # 显示指定链接动态库</code><br>同样的link_libraries 也可以使用这样的写法</li>
</ol>
<h2 id="如何指定头文件查找目录"><a href="#如何指定头文件查找目录" class="headerlink" title="如何指定头文件查找目录"></a>如何指定头文件查找目录</h2><p>include_directories([AFTER|BEFORE] [SYSTEM] dir1 [dir2 …])<br>它相当于g++选项中的-I参数的作用，也相当于环境变量中增加路径到CPLUS_INCLUDE_PATH变量的作用。对于多级目录的项目，每个CMakeLists.txt都有自己的头文件查找路径，上述命令只是指定本CMake模块的头文件查找路径。需要注意的是，include_directores命令是非全局的，但是是可以继承父级目录CMake的设置的。</p>
<p>这里有两个重点：</p>
<ol>
<li>每个CMakeList.txt都有自己的头文件查找路径，可以继承父级目录</li>
<li>相当于在系统的查找目录中再添加路径。</li>
</ol>
<h2 id="如何指定源文件"><a href="#如何指定源文件" class="headerlink" title="如何指定源文件"></a>如何指定源文件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">aux_source_directory(&lt;dir&gt; &lt;variable&gt;)</span><br></pre></td></tr></table></figure>
<p>该命令会查找指定目录下的所有源文件，然后将结果存进指定变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">file(GLOB_RECURSE E8600_GUI_SRC_LIST *.cpp *.c)</span><br></pre></td></tr></table></figure>
<p>递归查找当前目录下的所有源文件，将结果存进指定变量中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">list(APPEND AWPI_SRC_LIST $&#123;PLATFORM_SRC&#125;)</span><br></pre></td></tr></table></figure>
<p>可以利用list命令将源文件拼接起来。</p>
<h2 id="如何添加子目录"><a href="#如何添加子目录" class="headerlink" title="如何添加子目录"></a>如何添加子目录</h2><p><code>add_subdirectory(&lt;dir&gt;)</code>指定子目录下的文件也需要处理，Cmake会去解析子目录下的CMakeList.txt，默认不会自动处理子目录的。子目录CMakeLists.txt将从父目录CMakeLists.txt继承设置</p>
<h2 id="如何自定义编译选项"><a href="#如何自定义编译选项" class="headerlink" title="如何自定义编译选项"></a>如何自定义编译选项</h2><p>添加预编译宏：可以通过 add_definitions(-DMACRO)  MACRO指的是宏的名字, -D是宏命令的一部分<br>也</p>
<h2 id="如何设置变量"><a href="#如何设置变量" class="headerlink" title="如何设置变量"></a>如何设置变量</h2><p>内部变量有：<br>CMAKE_C_COMPILER：指定C编译器<br>CMAKE_CXX_COMPILER：<br>CMAKE_C_FLAGS：编译C文件时的选项，如-g；也可以通过add_definitions添加编译选项<br>EXECUTABLE_OUTPUT_PATH：可执行文件的存放路径<br>LIBRARY_OUTPUT_PATH：库文件路径<br>CMAKE_BUILD_TYPE:：build 类型(Debug, Release, …)，CMAKE_BUILD_TYPE=Debug<br>BUILD_SHARED_LIBS：Switch between shared and static libraries<br>内置变量的使用：<br>在CMakeLists.txt中指定，使用set cmake命令中使用，如cmake -DBUILD_SHARED_LIBS=OFF</p>
<h2 id="如何根据源代码中的定义来控制生成。"><a href="#如何根据源代码中的定义来控制生成。" class="headerlink" title="如何根据源代码中的定义来控制生成。"></a>如何根据源代码中的定义来控制生成。</h2><h2 id="加入一个配置头文件，用于处理-CMake-对源码的设置"><a href="#加入一个配置头文件，用于处理-CMake-对源码的设置" class="headerlink" title="加入一个配置头文件，用于处理 CMake 对源码的设置"></a>加入一个配置头文件，用于处理 CMake 对源码的设置</h2><p>configure_file (<br>“${PROJECT_SOURCE_DIR}/config.h.in”<br>“${PROJECT_BINARY_DIR}/config.h”<br>)<br>configure_file 命令用于加入一个配置头文件 config.h ，这个文件由 CMake 从 config.h.in 生成，通过这样的机制，将可以通过预定义一些参数和变量来控制代码的生成。<br>注意：config.h是CMake生成的，源代码中可以直接使用它，但是config.h.in是人为生成的，有一定的格式要求，用来指定编译选项。</p>
<p>生成一个编译选项：</p>
<h2 id="是否使用自己的-MathFunctions-库"><a href="#是否使用自己的-MathFunctions-库" class="headerlink" title="是否使用自己的 MathFunctions 库"></a>是否使用自己的 MathFunctions 库</h2><p>option (USE_MYMATH  “Use provided math implementation” ON) </p>
<p>根据选项来指定生成的逻辑：</p>
<h2 id="是否加入-MathFunctions-库"><a href="#是否加入-MathFunctions-库" class="headerlink" title="是否加入 MathFunctions 库"></a>是否加入 MathFunctions 库</h2><p>if (USE_MYMATH)<br>include_directories (“${PROJECT_SOURCE_DIR}/math”)<br>add_subdirectory (math)<br>set (EXTRA_LIBS ${EXTRA_LIBS} MathFunctions)<br>endif (USE_MYMATH)</p>
<h2 id="如何指定项目的依赖关系"><a href="#如何指定项目的依赖关系" class="headerlink" title="如何指定项目的依赖关系"></a>如何指定项目的依赖关系</h2><p>依赖关系是指定在编译本模块之前，那些模块必须先编译。<br>add_dependencies 可以指定依赖关系。</p>
<h2 id="工程多级目录，如何编写CMake文档"><a href="#工程多级目录，如何编写CMake文档" class="headerlink" title="工程多级目录，如何编写CMake文档"></a>工程多级目录，如何编写CMake文档</h2><p>首先注意分析代码，能否将代码根据目录来分成逻辑上具有一定的独立性的模块。在模块的根目录中新建一个CMake目标，将此模块作为一个静态库项目来编写CMakeLists.txt，利用源文件收集命令收集源文件，指定头文件目录、指定库的依赖关系和链接关系。模块生成的目标名是在整个CMake大工程命名空间的，其它模块可以指定通过名字指定对本模块的依赖。但头文件的查找目录指定是各个模块独立的，子模块的设置可以继承父模块的设置。</p>
<p>顶级父模块中只做好全局的一些设置，比如编译参数、编译宏，指定编译器、设置编译开关等。子模块中设置的变量在父模块中是不可见的。</p>
<p>CMake分析CMakeLists.txt时，是根据中命令来顺序分析的，注意子模块的目标的依赖关系指定，基于目标名的依赖关系必须要求能在分析到此部分代码时能找到目标名。</p>
<h2 id="如何添加编译后事件"><a href="#如何添加编译后事件" class="headerlink" title="如何添加编译后事件"></a>如何添加编译后事件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">add_custom_command(TARGET $&#123;PROJECT_NAME&#125;</span><br><span class="line">    POST_BUILD</span><br><span class="line">    COMMAND echo &quot;hello world&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>使用上述的命令，可以指定任意目标的编译后事件.</p>
<h2 id="如何安装和测试代码"><a href="#如何安装和测试代码" class="headerlink" title="如何安装和测试代码"></a>如何安装和测试代码</h2><h2 id="安装和测试"><a href="#安装和测试" class="headerlink" title="安装和测试"></a>安装和测试</h2><h2 id="生成安装包"><a href="#生成安装包" class="headerlink" title="生成安装包"></a>生成安装包</h2><h2 id="参考文档："><a href="#参考文档：" class="headerlink" title="参考文档："></a>参考文档：</h2><ol>
<li><a href="http://www.hahack.com/codes/cmake/" target="_blank" rel="noopener">http://www.hahack.com/codes/cmake/</a></li>
</ol>
]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>cmake</tag>
      </tags>
  </entry>
  <entry>
    <title>使用ssh端口转发功能</title>
    <url>/2018/05/24/%E5%85%B6%E5%AE%83/%E4%BD%BF%E7%94%A8ssh%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<p>需要使用到本功能的场景主要是存在防火墙的情况下，由分为两种不同的场景：防火墙允许外面连接墙内的22端口；防火墙只允许出，不允许进。</p>
<a id="more"></a>

<h2 id="防火墙允许进"><a href="#防火墙允许进" class="headerlink" title="防火墙允许进"></a>防火墙允许进</h2><p>比如说：墙内有两台服务器B、C，墙外有需要访问的设备A，A可以ssh连接B，只有墙内的机器才能连接C。</p>
<p>这种情况下需要使用到ssh的本地转发功能，通过A连接B建立一个隧道，在A上开一个新的端口，所有与A上新端口建立连接的数据都会被B转发到C上的相关端口，从而实现A与C的间接通信的问题。</p>
<p>如果使用ssh.exe的话，可以使用如下的命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh -fN -L 17176:localhost:17176 root@192.168.0.206 -p 22</span><br></pre></td></tr></table></figure>

<p>如果使用putty.exe的话，可以使用如下的命令:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">putty.exe -L 17176:localhost:17176 -pw root root@192.168.0.206 -P 22 -N</span><br></pre></td></tr></table></figure>

<p>其中第1个17176是A上新开的监听端口，localhost指的是C机器地址，命令里B、C是同一台机器，因此可以使用localhost，第2个17176是要C机器提供服务的端口，<code>root@192.168.0.206</code>是ssh登录B设备的信息。</p>
<h2 id="防火墙不允许进"><a href="#防火墙不允许进" class="headerlink" title="防火墙不允许进"></a>防火墙不允许进</h2><p>比如说：墙内有两台服务器B、C，墙外有需要访问的设备A。A不能连接墙内的任何机器，但是B可以连接A，只有墙内的机器才能连接C。</p>
<p>这种情况下需要使用到ssh的远程转发功能，通过B连接A建立一个隧道，在A上开一个新的端口，所有与A上新端口建立连接的数据都会通过隧道到达B，然后被B转发到C上的相关端口，从而实现A与C的间接通信的问题。</p>
<p>如果使用ssh.exe的话，可以使用如下的命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh -fN -R 17176:localhost:17176 root@192.168.0.200 -p 22</span><br></pre></td></tr></table></figure>

<p>如果使用putty.exe的话，可以使用如下的命令：</p>
<pre><code>putty.exe -R 17176:localhost:17176 -pw root root@192.168.0.200 -P 22 -N</code></pre><p>其中第1个17176是A上新开的监听端口，localhost指的是C机器地址，命令里B、C是同一台机器，因此可以使用localhost，第2个17176是要C机器提供服务的端口，<code>root@192.168.0.200</code>是ssh登录A设备的信息。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>端口转发的原理就是建立隧道。因为ssh服务器端和客户端程序内部已经支持了这种功能，他们能够识别出本次建立的这个连接是要正常ssh登录，还是只是转发数据目的。了解了两端的ssh程序内部提供了这个功能，那么剩下的要使用端口转发的功能就只剩下如何建立TCP连接的这一步了。因为绝大部分防火墙都是状态防火墙，防火墙的拦截只是针对TCP的建立连接报文，只要通过防火墙建立了TCP连接，那么就能正常的通信。</p>
<p>因此，根据防火墙是否允许进入，我们需要选择使用本地转发还是远端转发。如果防火墙可进，那么我们在本地A发起连接连接到B，建立隧道。如果防火墙只出不进，那么我们通过B发起连接连接到A，建立隧道。因此，本地转发和远程转发看起来命令格式差不多，看起来很难理解，其实我们只要理解上面这段话就行。实际执行时的差异就是：<strong>本地转发的命令是在A机器上执行，远程转发的命令是在B机器上执行的。</strong></p>
]]></content>
      <categories>
        <category>其它</category>
        <category>ssh</category>
      </categories>
      <tags>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title>交叉编译移植过的库记录</title>
    <url>/2020/05/11/%E5%85%B6%E5%AE%83/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E8%BF%87%E7%9A%84%E5%BA%93%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h2 id="libnetfilter-conntrack"><a href="#libnetfilter-conntrack" class="headerlink" title="libnetfilter_conntrack"></a>libnetfilter_conntrack</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source &#x2F;opt&#x2F;crossplatform&#x2F;arm49&#x2F;env.sh</span><br><span class="line">.&#x2F;configure --host&#x3D;arm-linux-gnueabihf --prefix&#x3D;&#x2F;opt&#x2F;crossplatform&#x2F;arm49</span><br></pre></td></tr></table></figure>

<h2 id="libnfnetlink"><a href="#libnfnetlink" class="headerlink" title="libnfnetlink"></a>libnfnetlink</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source &#x2F;opt&#x2F;crossplatform&#x2F;arm49&#x2F;env.sh</span><br><span class="line">.&#x2F;configure --host&#x3D;arm-linux-gnueabihf --prefix&#x3D;&#x2F;opt&#x2F;crossplatform&#x2F;arm49</span><br></pre></td></tr></table></figure>

<h2 id="iptables"><a href="#iptables" class="headerlink" title="iptables"></a>iptables</h2><p>依赖：libnfnetlink、libnetfilter_conntrack</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source &#x2F;opt&#x2F;crossplatform&#x2F;arm49&#x2F;env.sh</span><br><span class="line">.&#x2F;configure --host&#x3D;arm-linux-gnueabihf --prefix&#x3D;&#x2F;opt&#x2F;crossplatform&#x2F;arm49</span><br></pre></td></tr></table></figure>

<h2 id="fft3-3-8"><a href="#fft3-3-8" class="headerlink" title="fft3.3.8"></a>fft3.3.8</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source &#x2F;opt&#x2F;crossplatform&#x2F;arm49&#x2F;env.sh</span><br><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;opt&#x2F;crossplatform&#x2F;arm49 --host&#x3D;arm-linux --enable-shared --enable-float --enable-threads</span><br></pre></td></tr></table></figure>
<p>这个库的配置–host必须使用arm-linux，因为config.sub版本过来的原因</p>
<h2 id="openssl-1-1-1"><a href="#openssl-1-1-1" class="headerlink" title="openssl 1.1.1"></a>openssl 1.1.1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source &#x2F;opt&#x2F;crossplatform&#x2F;arm49&#x2F;env.sh</span><br><span class="line">.&#x2F;config no-asm –prefix&#x3D;&#x2F;opt&#x2F;crossplatform&#x2F;arm49</span><br><span class="line">然后修改Makefile文件，将其中的-m64都删除掉</span><br><span class="line">make </span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>

<h2 id="libpcap-1-9-1"><a href="#libpcap-1-9-1" class="headerlink" title="libpcap 1.9.1"></a>libpcap 1.9.1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source &#x2F;opt&#x2F;crossplatform&#x2F;arm49&#x2F;env.sh</span><br><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;opt&#x2F;crossplatform&#x2F;arm49 --host&#x3D;arm-linux-gnueabihf  --with-pcap&#x3D;linux</span><br></pre></td></tr></table></figure>

<h2 id="net-tools-1-6-0"><a href="#net-tools-1-6-0" class="headerlink" title="net-tools 1.6.0"></a>net-tools 1.6.0</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source &#x2F;opt&#x2F;crossplatform&#x2F;arm49&#x2F;env.sh</span><br><span class="line">make config   &#x2F;&#x2F; 将x.25 等相关配置关闭，否则编译会报错，最终配置如下。（某些配置关闭或开启不影响编译成功）</span><br><span class="line"></span><br><span class="line">Does your system support GNU gettext? (I18N) [n]</span><br><span class="line"> </span><br><span class="line">*</span><br><span class="line"> </span><br><span class="line">* Protocol Families.</span><br><span class="line"> </span><br><span class="line">*</span><br><span class="line"> </span><br><span class="line">UNIX protocol family (HAVE_AFUNIX) [y]</span><br><span class="line"> </span><br><span class="line">INET (TCP&#x2F;IP) protocol family (HAVE_AFINET) [y]</span><br><span class="line"> </span><br><span class="line">INET6 (IPv6) protocol family (HAVE_AFINET6) [n]</span><br><span class="line"> </span><br><span class="line">Novell IPX&#x2F;SPX protocol family (HAVE_AFIPX) [y]</span><br><span class="line"> </span><br><span class="line">Appletalk DDP protocol family (HAVE_AFATALK) [y]</span><br><span class="line"> </span><br><span class="line">AX25 (packet radio) protocol family (HAVE_AFAX25) [y]</span><br><span class="line"> </span><br><span class="line">NET&#x2F;ROM (packet radio) protocol family (HAVE_AFNETROM) [y]</span><br><span class="line"> </span><br><span class="line">Rose (packet radio) protocol family (HAVE_AFROSE) [n]</span><br><span class="line"> </span><br><span class="line">X.25 (CCITT) protocol family (HAVE_AFX25) [n]</span><br><span class="line"> </span><br><span class="line">Econet protocol family (HAVE_AFECONET) [n]</span><br><span class="line"> </span><br><span class="line">DECnet protocol family (HAVE_AFDECnet) [n]</span><br><span class="line"> </span><br><span class="line">Ash protocol family (HAVE_AFASH) [n]</span><br><span class="line"> </span><br><span class="line">*</span><br><span class="line"> </span><br><span class="line">* Device Hardware types.</span><br><span class="line"> </span><br><span class="line">*</span><br><span class="line"> </span><br><span class="line">Ethernet (generic) support (HAVE_HWETHER) [y]</span><br><span class="line"> </span><br><span class="line">ARCnet support (HAVE_HWARC) [y]</span><br><span class="line"> </span><br><span class="line">SLIP (serial line) support (HAVE_HWSLIP) [y]</span><br><span class="line"> </span><br><span class="line">PPP (serial line) support (HAVE_HWPPP) [y]</span><br><span class="line"> </span><br><span class="line">IPIP Tunnel support (HAVE_HWTUNNEL) [y]</span><br><span class="line"> </span><br><span class="line">STRIP (Metricom radio) support (HAVE_HWSTRIP) [y]</span><br><span class="line"> </span><br><span class="line">Token ring (generic) support (HAVE_HWTR) [y]</span><br><span class="line"> </span><br><span class="line">AX25 (packet radio) support (HAVE_HWAX25) [y]</span><br><span class="line"> </span><br><span class="line">Rose (packet radio) support (HAVE_HWROSE) [n]</span><br><span class="line"> </span><br><span class="line">NET&#x2F;ROM (packet radio) support (HAVE_HWNETROM) [y]</span><br><span class="line"> </span><br><span class="line">X.25 (generic) support (HAVE_HWX25) [n]</span><br><span class="line"> </span><br><span class="line">DLCI&#x2F;FRAD (frame relay) support (HAVE_HWFR) [y]</span><br><span class="line"> </span><br><span class="line">SIT (IPv6-in-IPv4) support (HAVE_HWSIT) [n]</span><br><span class="line"> </span><br><span class="line">FDDI (generic) support (HAVE_HWFDDI) [n]</span><br><span class="line"> </span><br><span class="line">HIPPI (generic) support (HAVE_HWHIPPI) [n]</span><br><span class="line"> </span><br><span class="line">Ash hardware support (HAVE_HWASH) [n]</span><br><span class="line"> </span><br><span class="line">(Cisco)-HDLC&#x2F;LAPB support (HAVE_HWHDLCLAPB) [n]</span><br><span class="line"> </span><br><span class="line">IrDA support (HAVE_HWIRDA) [y]</span><br><span class="line"> </span><br><span class="line">Econet hardware support (HAVE_HWEC) [n]</span><br><span class="line"> </span><br><span class="line">*</span><br><span class="line"> </span><br><span class="line">* Other Features.</span><br><span class="line"> </span><br><span class="line">*</span><br><span class="line"> </span><br><span class="line">IP Masquerading support (HAVE_FW_MASQUERADE) [n]</span><br><span class="line"> </span><br><span class="line">Build iptunnel and ipmaddr (HAVE_IP_TOOLS) [n]</span><br><span class="line"> </span><br><span class="line">Build mii-tool (HAVE_MII) [n]</span><br></pre></td></tr></table></figure>
<p>需要对源码进行一些处理，处理的内容有：</p>
<ul>
<li>将<code>if_tr.h</code>和<code>if_strip.h</code>复制到net-tools-1.60/ 下</li>
<li>修改源码<code>lib/strip.c</code>， 将 #include &lt;linux/if_strip.h&gt; 改为 #include “if_strip.h” </li>
<li>修改源码 <code>hostname.c</code> ，在 switch的default:后加上break;</li>
<li>修改源码 <code>lib/tr.c</code>    将<code>#include &lt;linux/if_tr.h&gt;</code>改为<code>#include &quot;if_tr.h&quot;</code></li>
<li>修改源码 <code>lib/inet_sr.c</code> 将  switch的default:后加上break;</li>
</ul>
<p>修改完成走最后执行make就能生成：netstat，ipconfig，route等命令。</p>
<h2 id="lrzsz"><a href="#lrzsz" class="headerlink" title="lrzsz"></a>lrzsz</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source &#x2F;opt&#x2F;crossplatform&#x2F;arm49&#x2F;env.sh</span><br><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;opt&#x2F;crossplatform&#x2F;arm49 </span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>


<h2 id="zlib-1-2-9"><a href="#zlib-1-2-9" class="headerlink" title="zlib 1.2.9"></a>zlib 1.2.9</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source &#x2F;opt&#x2F;crossplatform&#x2F;arm49&#x2F;env.sh</span><br><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;opt&#x2F;crossplatform&#x2F;arm49 </span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>


<h2 id="dropbear"><a href="#dropbear" class="headerlink" title="dropbear"></a>dropbear</h2><p>依赖zlib</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source &#x2F;opt&#x2F;crossplatform&#x2F;arm49&#x2F;env.sh</span><br><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;opt&#x2F;crossplatform&#x2F;arm49 --host&#x3D;arm-linux</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<h2 id="crontab"><a href="#crontab" class="headerlink" title="crontab"></a>crontab</h2><p>下载cronie源码：<a href="https://github.com/cronie-crond/cronie/" target="_blank" rel="noopener">https://github.com/cronie-crond/cronie/</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source &#x2F;opt&#x2F;crossplatform&#x2F;arm49&#x2F;env.sh</span><br><span class="line">.&#x2F;autugen.sh</span><br><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F; --host&#x3D;arm-linux</span><br><span class="line">make</span><br></pre></td></tr></table></figure>

<p>不要make install</p>
<p>在安装目录下创建var/spool目录，因为指定了安装位置为/,因此需要创建/var/spool目录。</p>
]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>交叉编译</tag>
      </tags>
  </entry>
  <entry>
    <title>交叉编译工具链配置</title>
    <url>/2019/01/29/%E5%85%B6%E5%AE%83/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E9%93%BE%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="host机器中的设置"><a href="#host机器中的设置" class="headerlink" title="host机器中的设置"></a>host机器中的设置</h2><p>通常来说，交叉编译工具链放置在某一个目录中，所有交叉编译使用到的头文件、库文件及相关工具按照一定的规则组织放在目录下。在使用IDE或者命令时，必须要指定交叉编译工具的位置等信息。</p>
<p>通过一段时间的经验总结发现，交叉编译的根本原理就是：更改编译时所用到的某些变量的内容，使得满足查找头文件、查找库文件、使用特定的工具的目的。重要的变量有：</p>
<ul>
<li>CC C文件的编译工具</li>
<li>CXX C++文件的编译工具</li>
<li>CPP 预处理工具</li>
<li>ARCH 架构信息</li>
<li>PATH 方便直接使用arm-linux-gcc等命令</li>
<li>C_INCLUDE_PATH C语言的头文件查找目录</li>
<li>CPLUS_INCLUDE_PATH C++语言的头文件目录</li>
<li>LDFLAGS 连接库查找目录</li>
</ul>
<p>交叉编译如果正确的指定了上面的内容，编译基本上是每啥问题的。为了方便使用，可以将针对某个具体的项目的交叉编译配置写入到某一个文件中，但是不建议将这些内容写入到/etc/profile等系统配置文件，因为这很有可能污染宿主机Linux平台的环境。</p>
<p>将交叉编译的配置信息放在独立文件中的还有一个好处是，方便我们对多个不同的交叉编译工具链管理。在宿主机常规编程时，不用考虑交叉编译环境。当需要交叉编译时，自行对应的脚本立马就配置好了相应的环境。自己可以指定交叉编译工具链相关文件的放置规则，实际上我自己确实也是这样做的。</p>
<h2 id="Configure工作的原理"><a href="#Configure工作的原理" class="headerlink" title="Configure工作的原理"></a>Configure工作的原理</h2><p>此部分内容为我的理解，可能会有问题。</p>
<p>很多时候，我们在<code>configure</code>命令的–host部分指定了arm-linux-guneabihf/arm-linux值，我们知道host的值用来指定编译出来的程序可以运行的设备。那么，这个部分的取值到底是怎么规定的呢？</p>
<ol>
<li>configure在处理host的值的时候，是调用config.sub脚本来完成解析的。</li>
<li>config.sub会根据传入的值猜测目标平台的信息，进而尝试使用对应的编译工具来编译程序，它并不会编译程序，而是设置编译时所需要的工具。它会设置$CC $AR等值。</li>
<li>make是会根据$CC的值来使用对应的工具，如果工具存在，且相关配置都正确，则编译也会很顺利。</li>
</ol>
<p>实际使用configure时可能会遇到设置–host=arm-linux-guneabihf会失败，设置–host=arm-linux则会成功。这就是因为项目中的config.sub文件太老了。同样，configure处理–build的值时使用config.guess脚本文件。</p>
<p>总之就是Configure会根据我们设置的参数来设置$CC等变量值，进而影响到编译。绝大多数情况下，我们指定PATH，并且配合Configure的–host就能正常交叉编译。但是，某些情况下，我们还需要手动指定更多的变量，这也就是我们上面要设置那么多变量的原因。</p>
<h2 id="我的交叉编译工具链管理方法"><a href="#我的交叉编译工具链管理方法" class="headerlink" title="我的交叉编译工具链管理方法"></a>我的交叉编译工具链管理方法</h2><ol>
<li>规定在 ** /opt/crossplatform/ ** 下用来保存各个不同的交叉编译工具链环境下,比如目录下有arm49、arm462等不同的项目所需要用到的不同环境。</li>
<li>适用于某个平台编译的库都放在对应交叉编译环境的根目录下，比如：/opt/crossplatform/arm49即为我当前工作所用到的交叉编译根目录。它下面有include、lib、bin、rootfs等文件。所有的我编译的第三方库、项目中由我所编译的库都放在对应的环境目录下。</li>
<li>交叉编译工具脚本分为两种，一种是.sh文件(env.sh)，一种是cmake文件(env.cmake)。前者的使用性更广，后者则专门为cmake编译系统所使用。</li>
<li>先使用<code>source /opt/crossplatform/arm49/env.sh</code> 来加载配置，然后就可以正常使用arm-linux-gcc类似格式的命令了。</li>
<li>当使用cmake，需要配置交叉编译工具链时，使用命令``</li>
</ol>
<p>典型的sh文件内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;sh</span><br><span class="line"></span><br><span class="line">PATH_TOOLCHAIN&#x3D;&#x2F;opt&#x2F;crossplatform&#x2F;arm49&#x2F;arm-linux-gnueabihf</span><br><span class="line">export ARCH&#x3D;arm</span><br><span class="line">export LDFLAGS&#x3D;&quot;-L&#x2F;opt&#x2F;crossplatform&#x2F;arm49&#x2F;lib&quot;</span><br><span class="line">export C_INCLUDE_PATH&#x3D;&#x2F;opt&#x2F;crossplatform&#x2F;arm49&#x2F;include </span><br><span class="line">export CPLUS_INCLUDE_PATH&#x3D;&#x2F;opt&#x2F;crossplatform&#x2F;arm49&#x2F;include</span><br><span class="line">export PATH&#x3D;$&#123;PATH&#125;:$&#123;PATH_TOOLCHAIN&#125;&#x2F;bin</span><br><span class="line">export CC&#x3D;arm-linux-gnueabihf-gcc</span><br><span class="line">export CXX&#x3D;arm-linux-gnueabihf-g++</span><br><span class="line">export CPP&#x3D;arm-linux-gnueabihf-cpp</span><br></pre></td></tr></table></figure>

<p>典型的cmake文件内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET(CMAKE_SYSTEM_NAME Linux)</span><br><span class="line">SET(TOOLCHAIN_DIR &quot;&#x2F;opt&#x2F;crossplatform&#x2F;arm49&#x2F;arm-linux-gnueabihf&quot;)</span><br><span class="line">SET(CMAKE_FIND_ROOT_PATH $&#123;TOOLCHAIN_DIR&#125;)</span><br><span class="line">SET(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)</span><br><span class="line">SET(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)</span><br><span class="line">SET(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)</span><br><span class="line"></span><br><span class="line">SET(CMAKE_C_COMPILER $&#123;TOOLCHAIN_DIR&#125;&#x2F;bin&#x2F;arm-linux-gnueabihf-gcc)</span><br><span class="line">SET(CMAKE_CXX_COMPILER $&#123;TOOLCHAIN_DIR&#125;&#x2F;bin&#x2F;arm-linux-gnueabihf-g++)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>交叉编译</tag>
      </tags>
  </entry>
  <entry>
    <title>如何选择设计模式</title>
    <url>/2020/05/21/%E5%85%B6%E5%AE%83/%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>具体的详细的介绍可以参考网站：<a href="https://refactoringguru.cn/design-patterns" target="_blank" rel="noopener">https://refactoringguru.cn/design-patterns</a></p>
<h2 id="构建型设计模式"><a href="#构建型设计模式" class="headerlink" title="构建型设计模式"></a>构建型设计模式</h2><ol>
<li>首先看对象的构造复杂不复杂，如果构造的步骤特别复杂，在new万之后还需要很多的配置步骤，这个就可以考虑使用生成器设计模式，将这些构建封装起来，不同的构造者就能得到不同的对象。</li>
<li>考虑是否需要使用单例</li>
<li>如果产品之间的关联性不大，但是需要根据配置来创建，可以考虑使用简单工厂，将new放在同一个地方，免得散落在各地。如果不需要根据配置来创建，就直接使用new就行了。</li>
<li>一组相关的产品，有着某种共同接口，如果产品个体之间存在互相替换的需要，考虑使用工厂方法。</li>
<li>如果产品之间存在一组替换另外一组，就考虑抽象工厂。前提是，产品之间能分组。</li>
</ol>
<h2 id="结构性设计模式"><a href="#结构性设计模式" class="headerlink" title="结构性设计模式"></a>结构性设计模式</h2><p>结构性主要关注，如何使得已有的类如何能更好的工作。</p>
<ol>
<li>如果一个方便更改的类，需要接入到系统。那就需要对新加入的类进行包装，加多一层符合现在系统的接口。这个就是适配器模式。</li>
<li>如果你希望在运行时给对象添加功能，可以考虑装饰器模式。一般是对某个接口增强。</li>
<li>如果实在是没法通过继承给某个类扩展功能，也可以使用装饰器模式。</li>
<li>如果有一个类，我们希望对他做一些保护，隐藏，访问控制，可以考虑添加一个包裹类，接口根原始类一模一样。这个就是代理模式。</li>
<li>如果现在系统的接口太多了，可以考虑在这些接口上新增加一层常用的接口，方便使用。如果不屏蔽对原接口的使用，这个就是外观模式，如果屏蔽对原接口的使用，那就是中介模式。这个是在系统变得复杂之后再考虑。</li>
<li>如果类的属性可以分为2个维度，比如颜色和形状，平台和控件，类是与抽象工厂，考虑考虑桥接模式，将2个维度分别抽出来。</li>
<li>如果类与类之间有明显的树形结构，则可以考虑组合结构。</li>
</ol>
<h2 id="行为型设计模式"><a href="#行为型设计模式" class="headerlink" title="行为型设计模式"></a>行为型设计模式</h2><p>行为型基本上就是根据某种特殊的功能，或者目的来总结的。</p>
<ol>
<li>如果需要消息通知，则使用观察者模式。</li>
<li>如果需要状态间切换，考虑使用状态模式。</li>
<li>针对不同的策略，使用不同的逻辑，使用策略。</li>
<li>如果是遍历，考虑迭代器模式</li>
<li>如果一个逻辑经过的过程算法是一样的，只是某些是否需要改动一点，考虑模板方法</li>
<li>消息链式传递，考虑责任链模式。但是，如果链的长度固定，顺序固定，也不一定需要。</li>
<li>如果需要撤销功能，考虑备忘录模式。</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实类与类之间的关系无非就是继承和组合，对象与对象之间是简单单向引用，还是互相双向引用。所有的设计模式，都是基于不同的目的，在这上面做文章而已。</p>
]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>使用hexo搭建自己的博客</title>
    <url>/2018/05/24/%E5%85%B6%E5%AE%83/%E4%BD%BF%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>windows上直接下载node.js安装文件和git安装文件来安装，注意添加到环境变量path中。打开git bash，输入以下两条命令就算是完成了hexo的博客框架。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>为了美化，还需要安装一下插件，这个部分可以根据实际情况来。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-helper-live2d --save</span><br><span class="line">npm install live2d-widget-model-wanko</span><br><span class="line">npm install hexo-generator-feed --save </span><br><span class="line">npm install hexo-symbols-ount-time --save</span><br><span class="line">npm install hexo-wordcount --save</span><br></pre></td></tr></table></figure>

<p>hexo自带的markdown渲染器感觉不是很强大，可以考虑使用如下的替换：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm un hexo-renderer-marked --save</span><br><span class="line">npm install hexo-renderer-markdown-it-plus --save</span><br></pre></td></tr></table></figure>
<p>安装完毕之后还需要设置，参考插件官网的设置即可</p>
<p>github配置可以安靠网上的其它的攻略，设置过一次之后就可以不管了。</p>
<h1 id="创建一个博客系统"><a href="#创建一个博客系统" class="headerlink" title="创建一个博客系统"></a>创建一个博客系统</h1><p>bash中进入某个文件夹后，执行命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npx hexo init  &#x2F;&#x2F; 初始化</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>
<p>上两步完成后就搭建好了一个博客系统，使用<code>npx hexo g</code> 和 <code>npx hexo s</code>就能生成博客文件和预览博客系统了。</p>
<h1 id="创建文章"><a href="#创建文章" class="headerlink" title="创建文章"></a>创建文章</h1><p>在shell中进入到hexo博客系统的根目录，然后使用如下的命令： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npx hexo new [布局] 文章名</span><br></pre></td></tr></table></figure>

<h1 id="调试和部署"><a href="#调试和部署" class="headerlink" title="调试和部署"></a>调试和部署</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npx hexo clean  #清除静态页面缓存（清除 public 文件夹）</span><br><span class="line">npx hexo g  #在本地生成静态页面（生成 public 文件夹）</span><br><span class="line">npx hexo s  #启动本地服务 http:&#x2F;&#x2F;localhost:4000，进行预览调试</span><br><span class="line">npx hexo d  #远程部署，同步到 GitHub</span><br></pre></td></tr></table></figure>


<h1 id="增加分类、关于我等页面"><a href="#增加分类、关于我等页面" class="headerlink" title="增加分类、关于我等页面"></a>增加分类、关于我等页面</h1><p>博客默认的菜单只有首页和归档两个，需要新增一个分类/关于我，或者新增一个自定义的菜单。新增菜单主要在两个地方处理，一个是在主题Next的中增加标签，另外一个是生成菜单下需要显示的页面。</p>
<p>在Next主题中添加要显示的菜单，只要打开主题的yml配置文件，找到menu配置项，反注释掉就行了。在menu中对每个菜单项制定了显示的页面路径，比如<code>categories: /categories/</code>。 分号后面的部分就是此菜单对应的页面了。路径是相对于站点根目录下的source目录。</p>
<p>使用hexo生成要一个页面，比如分类/关于我等也是很简单的。在shell中执行命令:<code>npx hexo new page 页面名</code>，指定页面名必须与主题中menu下的项目匹配。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npx hexo new page tags # 生成一个标签页面</span><br><span class="line">npx hexo new page categories # 生成分配页面</span><br><span class="line">npx hexo new page about # 生成关于我的页面</span><br></pre></td></tr></table></figure>
<p>命令执行完后将在source目录下生成以页面名命名的目录，目录中只有index.md文件。这样在博客中点击菜单时就能正常显示页面了。hexo对于分类和标签页面有默认的行为，只要我们修改index.md中的front-matter部分中type的值就能应用上，比如<code>categories</code> 表示默认分类页面样式。对于about和自定义的菜单页面，则需要自己去编辑相应的index.md文件了。</p>
<h1 id="hexo博客相关管理"><a href="#hexo博客相关管理" class="headerlink" title="hexo博客相关管理"></a>hexo博客相关管理</h1><p>hexo博客总共包含3个仓库来管理，一个是<code>.deploy_git</code>，一个是博客根目录并且排除掉<code>_posts</code>目录。最后一个是_posts目录。在重装系统时，建议将博客总目录整体打包备份。</p>
<p><code>.deploy_git</code>是使用github作为博客的发布平台所产生的，最后生成的静态博客页面一定会上传到此仓库。</p>
<p><code>_posts</code>目录独立作为一个仓库，因为里面全部是自己的笔记，也包含其它文档格式的笔记,比如docx、xmind等。hexo仅仅会处理md文档。独立作为一个仓库，也方便在不同的机器上进行编写，方便管理。</p>
<p>博客根目录作为一个仓库则是管理了所有针对hexo的配置和相关主题的配置，当然生成的中间文件是不会被管理的。</p>
<h1 id="增加Next主题的页面宽度"><a href="#增加Next主题的页面宽度" class="headerlink" title="增加Next主题的页面宽度"></a>增加Next主题的页面宽度</h1><p>方法一：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*对于 Pisces Scheme，需要同时修改 header 的宽度、.main-inner 的宽度以及 .content-wrap 的宽度。</span><br><span class="line">例如，使用百分比（Pisces 的布局定义在 source&#x2F;css&#x2F;_schemes&#x2F;Picses&#x2F;_layout.styl 中）：*&#x2F;</span><br><span class="line"></span><br><span class="line">header&#123; width: 90%; &#125;</span><br><span class="line">.container .main-inner &#123; width: 90%; &#125;</span><br><span class="line">.content-wrap &#123; width: calc(100% - 260px); &#125;</span><br></pre></td></tr></table></figure>
<p>方法二：<br>打开/Hexo/themes/hexo-theme-next/source/css/_variables/custom.styl 添加两行代码即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$main-desktop &#x3D; 1200px </span><br><span class="line">$content-desktop &#x3D; 900px</span><br></pre></td></tr></table></figure>

<h1 id="使用图片"><a href="#使用图片" class="headerlink" title="使用图片"></a>使用图片</h1><p>在source目录下新建一个目录放文件，比如images。在文章中需要放图片的地方使用<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="/images/xxx.png" alt=""></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">hexo官方文档</a></li>
<li><a href="http://shenzekun.cn/hexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B.html/" target="_blank" rel="noopener">Next主题美化</a></li>
<li><a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">Next官网</a></li>
</ol>
]]></content>
      <categories>
        <category>其它</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>字符编码理解</title>
    <url>/2018/05/25/%E5%85%B6%E5%AE%83/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<p>C/C++ 对于字符编码的处理尤其痛苦，经常需要对字符进行转换，宽字符、多字节等概念让人头大。这里主要记录下自己对字符编码的相关理解。</p>
<a id="more"></a>

<h1 id="抽象字符表"><a href="#抽象字符表" class="headerlink" title="抽象字符表"></a>抽象字符表</h1><p>字符集的意思是所有我们所要表示字符的一个集合，这个所关注的就是一个字符集了。比如我们有拉丁字母字符集，中文字符集、日文字符集等。这种字符可以认为是抽象的字符，这个抽象字符表就相当于一个数据库了。</p>
<h1 id="编码字符集"><a href="#编码字符集" class="headerlink" title="编码字符集"></a>编码字符集</h1><p>有了抽象字符表，我们还需要对这个表进行整理，进行编码。编码的意思是对字符集中的所有字符，给定一个映射方案，把每个字符都唯一的映射到一个编号的过程，这个编号也叫一个码点。对一个抽象字符表来说，这种编码方案不一定是唯一的。比如，我们可以将拉丁字母表编码成摩斯电码，也可以编码成ASCII。对于计算机来说，早期只有ASCII编码方案，后来各个地区的人们在ASCII的基础上扩展出了各种表示自己语言的方案，比如法语编码方案、德语编码方案、中文编码方案。这种各自为政的字符集编码方法，必然存在这冲突，比如同样的一个编码出来的码元，在法语中表示的是这个意思，在德语中可能就是另外一个意思了。</p>
<p>对于某一种编码方法得到的字符到码点的映射，所有的码点就组成了一种编码字符集。</p>
<h1 id="代码页"><a href="#代码页" class="headerlink" title="代码页"></a>代码页</h1><p>有了抽象字符的编码方案，我们还需要对这种方案进行命名，这个命名就是代码页的概念了。注意，代码页表示的是对编码方案的命名，不代表编码方案只能通过代码页这一概念来表示。具体的某个代码页等同于一种具体的编码方案。这样，对于具体的某一个二进制序列，只要告诉我这是使用哪一种编码方案（代码页），也就能知道它表达的是什么含义了。</p>
<h1 id="存储方案"><a href="#存储方案" class="headerlink" title="存储方案"></a>存储方案</h1><p>有了编码字符集（编码方案），还需要确定的存储方案，即对于具体某一个码点，到底怎么存储。存储没想象中那么简单，必须考虑如何识别，考虑大小端等。早期对各自独立的编码方案，码点也就是各自的存储方案了。</p>
<p>对于早期的计算机来说，给定一段二进制代码，只要给定代码页（其实还需要存储方案，但一般等同于代码页），也就能知道其具体的意思。</p>
<h1 id="unicode的出现"><a href="#unicode的出现" class="headerlink" title="unicode的出现"></a>unicode的出现</h1><p>早期各子的编码字符集（编码方案）在各自地区使用没问题，一旦需要跟其它系统交流，码点很容易冲突。为了解决这种冲突。早期微软是采用代码页的方式来解决。这样一定程度上解决了数据的交流问题，但这种方案还不够优秀。</p>
<p>随着互联网的发展，最终人们决定够用一个通用的方案，那就是UNICODE方案。Unicode构造一个巨大的抽象字符表，把所有的能用到的字符都放到这个表中，给定一个码点。刚开始，Unicode使用2个字节来编码所有的字符，也就是每个码点都是2个字节的，这就是ucs-2的编码方案。后来发现，2个字节是不够的，于是又弄出来了个4字节的方案，这就是ucs-4的编码方案。但是现在人们常用的基本上都是是ucs-2，代码开发中指的Unicode也是指ucs-2. </p>
<h1 id="utf编码"><a href="#utf编码" class="headerlink" title="utf编码"></a>utf编码</h1><p>弄出来个ucs-2编码方案后，还需要考虑存储/传输方案，utf编码就是Unicode的传输方案了。UTF(UCS Transformation Format)规范设计时考虑了一些现实问题。即在UCS定义之前，已经存在大量的ASCII程序。新定义的UCS的表示方法必须兼容原始的ascii程序和方法。这个问题也可以表示为，Unicode使用2个字节表示一个字符,ascii使用1个字节,在很多方面产生了冲突，以前处理ascii的方法都必须重写。而且C语言用<code>\0</code>作为字符串结束标志,但Unicode中很多字符都含<code>\0</code>,C语言的字符串函数也无法正常处理Unicode。为了把unicode投入实用,出现了UTF,最常见的是UTF-8、UTF-16和UTF-32。</p>
<p>常见的UTF规范包括UTF-8、UTF-7、UTF-16、UTF-32。utf-8是存储方案的基本码位是8位，也就是最少使用8位，可以是16位、24位、32位等。utf-16的存储方案基本码位是16位，可以是16位、32位等。解析他们时必须按照码位来一个一个解析。utf-16则必须一次处理2个字节，理解其含义。由于utf-16处理的基本码位时16位，在取到数据时，我们还必须知道当前处理的2个字节，哪个时高字节，哪个时低字节。因此，utf-16由分为utf-16-le和 utf-16-be</p>
<h1 id="BOM和UTF8"><a href="#BOM和UTF8" class="headerlink" title="BOM和UTF8"></a>BOM和UTF8</h1><p>UCS规范建议我们在传输字节流前，先传输 字符”ZERO WIDTH NO-BREAK SPACE”。这样如果接收者收到FEFF，就表明这个字节流是Big-Endian的；如果收到FFFE，就表明这个字节流是Little- Endian的。因此字符”ZERO WIDTH NO-BREAK SPACE”又被称作BOM。BOM（byte order mark）是为 UTF-16 和 UTF-32 准备的，用于标记字节序（byte order）。UTF-8 不需要 BOM，尽管 Unicode 标准允许在 UTF-8 中使用 BOM。UTF-8中使用BOM不是用来表明字节顺序的，而是用来表明编码方式。字符”ZERO WIDTH NO-BREAK SPACE”的UTF-8编码是EF BB BF，所以如果接收者收到以EF BB BF开头的字节流，就知道这是UTF-8编码了。这也是微软的做法。微软正是用这种方法（在 UTF-8 中使用 BOM）， 把 UTF-8 和 ASCII 等编码明确区分开来，但这样的文件在 Windows 之外的操作系统里会带来问题。Unix社区尤其反对。所以不含 BOM 的 UTF-8 才是标准形式，在 UTF-8 文件中放置 BOM 主要是微软的习惯</p>
]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>字符编码</tag>
      </tags>
  </entry>
  <entry>
    <title>开发相关技术了解</title>
    <url>/2018/06/17/%E5%85%B6%E5%AE%83/%E5%BC%80%E5%8F%91%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF%E4%BA%86%E8%A7%A3/</url>
    <content><![CDATA[<p>工作中能用到的几乎全是嵌入式相关的开发，所用到的技术面较窄。但是作为一个开发者，还是需要对各个开发技术有一个直观的印象才行。</p>
<a id="more"></a>

<h2 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h2><h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><ul>
<li>ActionScript: 运用在flash上的脚本语言，多用于Flash互动性、娱乐性、实用性开发，网页制作和RIA（丰富互联网程序）开发</li>
<li>Akka：JAVA虚拟机JVM平台上构建高并发、分布式和容错应用的工具包和运行时。</li>
<li>Actor模型： Actor是计算机科学领域中的一个并行计算模型，它把actors当做通用的并行计算原语：一个actor对接收到的消息做出响应，进行本地决策，可以创建更多的actor，或者发送更多的消息；同时准备接收下一条消息。</li>
<li>Angular: 由谷歌维护的一个开源JavaScript框架,目前有两个大的版本，一个是Angular 1.5，一个是Angular 4.0。两个版本的差别非常大，4.0是一个完全重写的版本。Angular1.5叫AngularJS，Angular 2.0之后的都只叫Angular。</li>
<li>Ansible：运维自动化工具( 配置管理 )</li>
<li>SaltStack： 运维自动化工具( 配置管理 )</li>
<li>Puppet：运维自动化工具( 配置管理 )</li>
<li>Arduino: 一套便捷、灵活、容易上手的硬件开发平台，它包括多种型号的Arduino控制电路板，和专用编程开发软件。Arduino省略了很多繁琐的底层开发，让人们可以专注在功能实现，快速的开发出智能硬件原型。Arduino的硬件价格也相对便宜，所以，Arduino可以说是适合每个人的硬件开发平台.</li>
<li>Bootstrap: 自Twitter，是目前最受欢迎的前端框架。Bootstrap 是基于HTML、CSS、JAVASCRIPT的，它简洁灵活，使得 Web 开发更加快捷</li>
</ul>
]]></content>
      <categories>
        <category>其它</category>
      </categories>
  </entry>
  <entry>
    <title>总结常用设计模式-创建型设计模式</title>
    <url>/2018/05/25/%E5%85%B6%E5%AE%83/%E6%80%BB%E7%BB%93%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>具体的详细的介绍可以参考网站：<a href="https://refactoringguru.cn/design-patterns" target="_blank" rel="noopener">https://refactoringguru.cn/design-patterns</a></p>
<h2 id="行为型设计模式"><a href="#行为型设计模式" class="headerlink" title="行为型设计模式"></a>行为型设计模式</h2><h3 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h3><p>简单就是所相比原来的直接New不同的产品，现在提供一个统一的接口来创建不同的产品，区分要产品的具体是哪一个靠的是统一接口的参数，一般是字符串类型或者整型，这些参数可以保存在配置文件中。这是较为简单但是很实用的设计模式。</p>
<p>缺点是，如果要添加新的产品，必须修改工厂的统一创建接口，内部一般是用if语句或者switch语句来判断要创建的对象。</p>
<h3 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h3><p>简单工厂中如果要添加子产品很麻烦，必须得修改工厂中接口的实现。重构经验告诉我们，要把if语句重构成不用if的方法就是使用多态。针对简单工厂的缺点，我们只需要针对工厂来方法的创建接口来进行抽象就行。</p>
<p>现在有抽象的工厂，有具体的工厂，工厂都能产出某一类产品，客户端调用时不用关心不同的工厂的不同。调用工厂方法的代码 （通常被称为客户端代码） 无需了解不同子类返回实际对象之间的差别。</p>
<p>使用场景：</p>
<ol>
<li><p>如果你希望复用现有对象来节省系统资源， 而不是每次都重新创建对象， 可使用工厂方法。构造函数始终返回的是新对象， 其无法返回现有实例。<br>因此， 你需要有一个既能够创建新对象， 又可以重用现有对象的普通方法。 这听上去和工厂方法非常相像。</p>
</li>
<li><p>如果你希望用户能扩展你软件库或框架的内部组件， 可使用工厂方法。</p>
</li>
</ol>
<p>实现方法：</p>
<ol>
<li><p>让所有产品都遵循同一接口。 该接口必须声明对所有产品都有意义的方法。</p>
</li>
<li><p>在创建类中添加一个空的工厂方法。 该方法的返回类型必须遵循通用的产品接口。</p>
</li>
<li><p>在创建者代码中找到对于产品构造函数的所有引用。 将它们依次替换为对于工厂方法的调用， 同时将创建产品的代码移入工厂方法。 你可能需要在工厂方法中添加临时参数来控制返回的产品类型。</p>
</li>
<li><p>现在， 为工厂方法中的每种产品编写一个创建者子类， 然后在子类中重写工厂方法， 并将基本方法中的相关创建代码移动到工厂方法中。</p>
</li>
<li><p>如果应用中的产品类型太多， 那么为每个产品创建子类并无太大必要， 这时你也可以在子类中复用基类中的控制参数。</p>
</li>
</ol>
<p>6。 如果代码经过上述移动后， 基础工厂方法中已经没有任何代码， 你可以将其转变为抽象类。 如果基础工厂方法中还有其他语句， 你可以将其设置为该方法的默认行为。</p>
<h3 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h3><p>前面工厂方法针对的是一种产品的情况，那如果针对多个产品形成了产品族或者某个风格的产品的情况，如果还使用工厂方法就会导致复杂度上升，工厂类数据急剧增加。</p>
<p>多个产品不形成产品族或者说它们之间的逻辑上联系本来就少的话，就不再我们这里讨论范畴，把它们当作一个一个不同的产品就行，每个产品如果有需要使用工厂方法就行。</p>
<p>产品族或者说某个风格的产品其实仅仅是增加了产品的一个维度，有一个新的维度来对产品分类。软件设计的软件就是封装变化。因此抽象工厂就是在工厂方法的基础上进一进行了封装。</p>
<p>抽象工厂中现在多了一些接口，用来创建不同的产品。具体的工厂现在代表的是一个产品组或者某个风格的产品系列。</p>
<h3 id="生成器模式"><a href="#生成器模式" class="headerlink" title="生成器模式"></a>生成器模式</h3><p>前面三种创建型的设计模式主要关注于不同种类的产品的创建，如何提供适当的方法来创建同种产品，如何创建某个产品族。</p>
<p>对于某一个复杂的具体产品，产品分为很多个部件，不同的特性的部件最终生成了不同的产品。在类图上表现为，产品没有继承关系，但是属性很多。如果不使用设计模式的话，针对每个具体的产品对象，需要在new之后调用很多成员函数来完成对产品的进行配置，配置完成才算是产品的创建完成。如果只有一个地方需要某种特性的产品，那还好，如果多个地方都需要的话，重复的代码量就很多了。</p>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>这个就不说了。</p>
<h2 id="模式对比与联系"><a href="#模式对比与联系" class="headerlink" title="模式对比与联系"></a>模式对比与联系</h2><p>在许多设计工作的初期都会使用工厂方法模式 （较为简单， 而且可以更方便地通过子类进行定制）， 随后演化为使用抽象工厂模式、 原型模式或生成器模式 （更灵活但更加复杂）。</p>
<p>抽象工厂模式通常基于一组工厂方法， 但你也可以使用原型模式来生成这些类的方法。</p>
<p>工厂方法是模板方法模式的一种特殊形式。 同时， 工厂方法可以作为一个大型模板方法中的一个步骤。</p>
<p>原型并不基于继承， 因此没有继承的缺点。 另一方面， 原型需要对被复制对象进行复杂的初始化。 工厂方法基于继承， 但是它不需要初始化步骤。</p>
<p>你可以将抽象工厂和桥接模式搭配使用。 如果由桥接定义的抽象只能与特定实现合作， 这一模式搭配就非常有用。 在这种情况下， 抽象工厂可以对这些关系进行封装， 并且对客户端代码隐藏其复杂性。</p>
<p>当只需对客户端代码隐藏子系统创建对象的方式时， 你可以使用抽象工厂来代替外观模式。</p>
]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>总结常用设计模式-行为型设计模式</title>
    <url>/2018/05/25/%E5%85%B6%E5%AE%83/%E6%80%BB%E7%BB%93%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>具体的详细的介绍可以参考网站：<a href="https://refactoringguru.cn/design-patterns" target="_blank" rel="noopener">https://refactoringguru.cn/design-patterns</a></p>
<h2 id="行为型设计模式"><a href="#行为型设计模式" class="headerlink" title="行为型设计模式"></a>行为型设计模式</h2><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>又叫做： 事件订阅者、 监听者、 Event-Subscriber、 Listener、 Observer</p>
<p>目的就是定义了一种订阅机制， 可在对象事件发生时通知多个 “观察” 对象。实现方式：</p>
<ol>
<li><p>仔细检查你的业务逻辑， 试着将其拆分为两个部分： 独立于其他代码的核心功能将作为发布者； 其他代码则将转化为一组订阅类。</p>
</li>
<li><p>声明订阅者接口。 该接口至少应声明一个 update方法。</p>
</li>
<li><p>声明发布者接口并定义一些接口来在列表中添加和删除订阅对象。 记住发布者必须仅通过订阅者接口与它们进行交互。</p>
</li>
<li><p>确定存放实际订阅列表的位置并实现订阅方法。 通常所有类型的发布者代码看上去都一样， 因此将列表放置在直接扩展自发布者接口的抽象类中是显而易见的。 具体发布者会扩展该类从而继承所有的订阅行为。</p>
</li>
</ol>
<p>但是， 如果你需要在现有的类层次结构中应用该模式， 则可以考虑使用组合的方式： 将订阅逻辑放入一个独立的对象， 然后让所有实际订阅者使用该对象。</p>
<ol start="4">
<li><p>创建具体发布者类。 每次发布者发生了重要事件时都必须通知所有的订阅者。</p>
</li>
<li><p>在具体订阅者类中实现通知更新的方法。 绝大部分订阅者需要一些与事件相关的上下文数据。 这些数据可作为通知方法的参数来传递。但还有另一种选择。 订阅者接收到通知后直接从通知中获取所有数据。 在这种情况下， 发布者必须通过更新方法将自身传递出去。 另一种不太灵活的方式是通过构造函数将发布者与订阅者永久性地连接起来。</p>
</li>
<li><p>客户端必须生成所需的全部订阅者， 并在相应的发布者处完成注册工作。</p>
</li>
</ol>
<h3 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式"></a>模板模式</h3><p>在超类中定义了一个算法的框架， 允许子类在不修改结构的情况下重写算法的特定步骤。</p>
<h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p>定义一系列算法， 并将每种算法分别放入独立的类中， 以使算法的对象能够相互替换。</p>
<ol>
<li><p>从上下文类中找出修改频率较高的算法 （也可能是用于在运行时选择某个算法变体的复杂条件运算符）。</p>
</li>
<li><p>声明该算法所有变体的通用策略接口。</p>
</li>
<li><p>将算法逐一抽取到各自的类中， 它们都必须实现策略接口。</p>
</li>
<li><p>在上下文类中添加一个成员变量用于保存对于策略对象的引用。 然后提供设置器以修改该成员变量。 上下文仅可通过策略接口同策略对象进行交互， 如有需要还可定义一个接口来让策略访问其数据。</p>
</li>
<li><p>客户端必须将上下文类与相应策略进行关联， 使上下文可以预期的方式完成其主要工作。</p>
</li>
</ol>
<p>缺点：</p>
<ol>
<li>如果你的算法极少发生改变， 那么没有任何理由引入新的类和接口。 使用该模式只会让程序过于复杂。</li>
<li>客户端必须知晓策略间的不同——它需要选择合适的策略。</li>
<li>许多现代编程语言支持函数类型功能， 允许你在一组匿名函数中实现不同版本的算法。 这样， 你使用这些函数的方式就和使用策略对象时完全相同， 4. 无需借助额外的类和接口来保持代码简洁。</li>
</ol>
<h3 id="职责链模式"><a href="#职责链模式" class="headerlink" title="职责链模式"></a>职责链模式</h3><p>又叫做： 职责链模式、 命令链、 CoR、 Chain of Command、 Chain of Responsibility</p>
<p>一般只在特殊数据结构中可能出现，比如树形结构，GUI的UI树响应点击事件就是一种。</p>
<ol>
<li>当必须按顺序执行多个处理者时， 可以使用该模式。</li>
<li>如果所需处理者及其顺序必须在运行时进行改变， 可以使用责任链模式。</li>
<li>当程序需要使用不同方式处理不同种类请求， 而且请求类型和顺序预先未知时， 可以使用责任链模式。</li>
</ol>
<p>实现方式：</p>
<ol>
<li>声明处理者接口并描述请求处理方法的签名。</li>
<li>为了在具体处理者中消除重复的样本代码， 你可以根据处理者接口创建抽象处理者基类。</li>
<li>依次创建具体处理者子类并实现其处理方法。 每个处理者在接收到请求后都必须做出两个决定：<ul>
<li>是否自行处理这个请求。</li>
<li>是否将该请求沿着链进行传递。</li>
</ul>
</li>
<li>客户端可以自行组装链， 或者从其他对象处获得预先组装好的链。 在后一种情况下， 你必须实现工厂类以根据配置或环境设置来创建链。</li>
<li>客户端可以触发链中的任意处理者， 而不仅仅是第一个。 请求将通过链进行传递， 直至某个处理者拒绝继续传递， 或者请求到达链尾。</li>
<li>由于链的动态性， 客户端需要准备好处理以下情况：<ul>
<li>链中可能只有单个链接。</li>
<li>部分请求可能无法到达链尾。</li>
<li>其他请求可能直到链尾都未被处理。</li>
</ul>
</li>
</ol>
<h3 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h3><p>提供一种通用的方法来遍历某种对象，外部不需要知道遍历的细节，只需要知道如何调用接口来完成遍历就行。比如std库的迭代器</p>
<h3 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h3><p>关键点就在状态和上下文互相引用，在状态中完成对业务逻辑的实现。因为有上下文，因此业务逻辑实现很容易实现。上下文内中只提供底层接口和保存当前状态，其它的状态转换和业务逻辑都在状态类中。</p>
<p>使用场景：</p>
<ol>
<li>如果对象需要根据自身当前状态进行不同行为， 同时状态的数量非常多且与状态相关的代码会频繁变更的话， 可使用状态模式。</li>
<li>如果某个类需要根据成员变量的当前值改变自身行为， 从而需要使用大量的条件语句时， 可使用该模式。</li>
<li>当相似状态和基于条件的状态机转换中存在许多重复代码时， 可使用状态模式。</li>
</ol>
<p>实现方式：</p>
<ol>
<li>确定哪些类是上下文。 它可能是包含依赖于状态的代码的已有类； 如果特定于状态的代码分散在多个类中， 那么它可能是一个新的类。</li>
<li>声明状态接口。 虽然你可能会需要完全复制上下文中声明的所有方法， 但最好是仅把关注点放在那些可能包含特定于状态的行为的方法上。</li>
<li>为每个实际状态创建一个继承于状态接口的类。 然后检查上下文中的方法并将与特定状态相关的所有代码抽取到新建的类中。在将代码移动到状态类的过程中， 你可能会发现它依赖于上下文中的一些私有成员。 你可以采用以下几种变通方式：<ul>
<li>将这些成员变量或方法设为公有。</li>
<li>将需要抽取的上下文行为更改为上下文中的公有方法， 然后在状态类中调用。 这种方式简陋却便捷， 你可以稍后再对其进行修补。</li>
<li>将状态类嵌套在上下文类中。 这种方式需要你所使用的编程语言支持嵌套类。    </li>
</ul>
</li>
<li>在上下文类中添加一个状态接口类型的引用成员变量， 以及一个用于修改该成员变量值的公有设置器。</li>
<li>再次检查上下文中的方法， 将空的条件语句替换为相应的状态对象方法。</li>
<li>为切换上下文状态， 你需要创建某个状态类实例并将其传递给上下文。 你可以在上下文、 各种状态或客户端中完成这项工作。 无论在何处完成这项工作， 该类都将依赖于其所实例化的具体类。</li>
</ol>
<p>缺点：</p>
<ol>
<li>如果状态机只有很少的几个状态， 或者很少发生改变， 那么应用该模式可能会显得小题大作。</li>
</ol>
<h2 id="模式对比与联系"><a href="#模式对比与联系" class="headerlink" title="模式对比与联系"></a>模式对比与联系</h2><p>状态可被视为策略的扩展。 两者都基于组合机制： 它们都通过将部分工作委派给 “帮手” 对象来改变其在不同情景下的行为。 策略使得这些对象相互之间完全独立， 它们不知道其他对象的存在。 但状态模式没有限制具体状态之间的依赖， 且允许它们自行改变在不同情景下的状态。</p>
<p>责任链模式、 命令模式、 中介者模式和观察者模式用于处理请求发送者和接收者之间的不同连接方式：<br>    - 责任链按照顺序将请求动态传递给一系列的潜在接收者， 直至其中一名接收者对请求进行处理。<br>    - 命令在发送者和请求者之间建立单向连接。<br>    - 中介者清除了发送者和请求者之间的直接连接， 强制它们通过一个中介对象进行间接沟通。<br>    - 观察者允许接收者动态地订阅或取消接收请求。</p>
<p>责任链通常和组合模式结合使用。 在这种情况下， 叶组件接收到请求后， 可以将请求沿包含全体父组件的链一直传递至对象树的底部。</p>
<p>责任链的管理者可使用命令模式实现。 在这种情况下， 你可以对由请求代表的同一个上下文对象执行许多不同的操作。</p>
<p>责任链和装饰模式的类结构非常相似。 两者都依赖递归组合将需要执行的操作传递给一系列对象。 但是，他们的目的完全不一样：<br>    - 装饰模式的目的是扩展对象的行为<br>    - 责任链则对传入链条的对象不做更改，仅仅是依据它做自己的逻辑。</p>
<p>中介者和观察者之间的区别往往很难记住。 在大部分情况下， 你可以使用其中一种模式， 而有时可以同时使用。</p>
<ol>
<li><p>中介者的主要目标是消除一系列系统组件之间的相互依赖。 这些组件将依赖于同一个中介者对象。 观察者的目标是在对象之间建立动态的单向连接， 使得部分对象可作为其他对象的附属发挥作用。有一种流行的中介者模式实现方式依赖于观察者。 中介者对象担当发布者的角色， 其他组件则作为订阅者， 可以订阅中介者的事件或取消订阅。 当中介者以这种方式实现时， 它可能看上去与观察者非常相似。</p>
</li>
<li><p>当你感到疑惑时， 记住可以采用其他方式来实现中介者。 例如， 你可永久性地将所有组件链接到同一个中介者对象。 这种实现方式和观察者并不相同， 但这仍是一种中介者模式。假设有一个程序， 其所有的组件都变成了发布者， 它们之间可以相互建立动态连接。 这样程序中就没有中心化的中介者对象， 而只有一些分布式的观察者。</p>
</li>
</ol>
<p>状态模式和策略模式 （在某种程度上包括适配器模式） 模式的接口非常相似。 实际上， 它们都基于组合模式——即将工作委派给其他对象， 不过也各自解决了不同的问题。</p>
<p>状态可被视为策略的扩展。 两者都基于组合机制： 它们都通过将部分工作委派给 “帮手” 对象来改变其在不同情景下的行为。 策略使得这些对象相互之间完全独立， 它们不知道其他对象的存在。 但状态模式没有限制具体状态之间的依赖， 且允许它们自行改变在不同情景下的状态。</p>
]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>配置自己的vim环境</title>
    <url>/2020/04/08/%E5%85%B6%E5%AE%83/%E9%85%8D%E7%BD%AE%E8%87%AA%E5%B7%B1%E7%9A%84vim%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<p>vim环境还是要有的，但是不值得花大力气去折腾，因此直接使用网上的spf13-vim方案吧。</p>
<h2 id="window下搭建"><a href="#window下搭建" class="headerlink" title="window下搭建"></a>window下搭建</h2><h3 id="下载gvim"><a href="#下载gvim" class="headerlink" title="下载gvim"></a>下载gvim</h3><p>gvim最好下载带lua支持的，官网默认的不带lua支持。可以从 <a href="https://tuxproject.de/projects/vim/" target="_blank" rel="noopener">https://tuxproject.de/projects/vim/</a> 下载。支持lua还需要下载lua.dll，可以从</p>
<p><a href="https://sourceforge.net/projects/luabinaries/files/5.3.3/Windows%20Libraries/Dynamic/lua-5.3.3_Win64_dll10_lib.zip/download" target="_blank" rel="noopener">https://sourceforge.net/projects/luabinaries/files/5.3.3/Windows%20Libraries/Dynamic/lua-5.3.3_Win64_dll10_lib.zip/download</a> 下载。</p>
<p>都下载完毕并放入gvim目录下后，可以在gvim的界面中输入<code>:lua print(&#39;hello&#39;)</code>查看结果。如果正确输出hello，则表示版本每问题。</p>
<h3 id="安装spf13-vim"><a href="#安装spf13-vim" class="headerlink" title="安装spf13-vim"></a>安装spf13-vim</h3><p>从 <a href="https://github.com/spf13/spf13-vim" target="_blank" rel="noopener">https://github.com/spf13/spf13-vim</a> 下载压缩包。右键以管理员权限执行 spf13-vim-windows-install.cmd， 会自动进行一些列的安装动作。</p>
<p>如果执行完了还没有安装插件的话，可以打开一个git bash，执行一下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim -u ~&#x2F;.vimrc.bundles +BundleInstall! +BundleClean +qall</span><br></pre></td></tr></table></figure>

<h3 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h3><p>已经安装好的环境，备份在网盘：vim配置目录中，直接下载，解压到~目录下即可。</p>
<h2 id="Linux环境安装"><a href="#Linux环境安装" class="headerlink" title="Linux环境安装"></a>Linux环境安装</h2><p>官网上的一键安装脚本总是因为无法下载而没法用，建议使用如下的方式手动安装。</p>
<p>先下载：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone -b 3.0 https:&#x2F;&#x2F;github.com&#x2F;spf13&#x2F;spf13-vim.git ~&#x2F;.spf13-vim-3</span><br></pre></td></tr></table></figure>

<p>然后进入~/.spf13-vim-3 目录，创建install.sh脚本，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line">ln -s ~&#x2F;.spf13-vim-3&#x2F;.vimrc ~&#x2F;.vimrc -f</span><br><span class="line">ln -s ~&#x2F;.spf13-vim-3&#x2F;.vimrc ~&#x2F;_vimrc -f</span><br><span class="line">ln -s ~&#x2F;.spf13-vim-3&#x2F;.vimrc.fork ~&#x2F;.vimrc.fork -f</span><br><span class="line">ln -s ~&#x2F;.spf13-vim-3&#x2F;.vimrc.bundles ~&#x2F;.vimrc.bundles -f</span><br><span class="line">ln -s ~&#x2F;.spf13-vim-3&#x2F;.vimrc.bundles.fork ~&#x2F;.vimrc.bundles.fork -f</span><br><span class="line">ln -s ~&#x2F;.spf13-vim-3&#x2F;.vimrc.before ~&#x2F;.vimrc.before -f</span><br><span class="line">ln -s ~&#x2F;.spf13-vim-3&#x2F;.vimrc.before.fork ~&#x2F;.vimrc.before.fork -f</span><br><span class="line">mkdir ~&#x2F;.spf13-vim-3&#x2F;.vim&#x2F;bundle -p</span><br><span class="line">ln -s ~&#x2F;.spf13-vim-3&#x2F;.vim ~&#x2F;.vim -f</span><br><span class="line"></span><br><span class="line">cd .vim&#x2F;bundle</span><br><span class="line">if [ ! -d ~&#x2F;.vim&#x2F;bundle&#x2F;vundle ]; then</span><br><span class="line">    git clone https:&#x2F;&#x2F;github.com&#x2F;gmarik&#x2F;vundle.git</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>最后在命令行中执行如下的内容就行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim -u ~&#x2F;.vimrc.bundles +BundleInstall! +BundleClean +qall</span><br></pre></td></tr></table></figure>

<h3 id="备份-1"><a href="#备份-1" class="headerlink" title="备份"></a>备份</h3><p>已经安装好的环境，备份在网盘：vim配置目录中，直接下载，解压到~目录下即可。</p>
<h2 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ~&#x2F;.spf13-vim-3</span><br><span class="line">git pull</span><br><span class="line">vim +BundleInstall! +BundleClean +q</span><br></pre></td></tr></table></figure>

<h2 id="自定义配置"><a href="#自定义配置" class="headerlink" title="自定义配置"></a>自定义配置</h2><p>配置可以分为几种：</p>
<ol>
<li>spf13默认的配置，这个可能随着spf13仓库的改变而可能改变</li>
<li>自己从spf13 fork出来的仓库从而自己创建的配置，fork目的是为了方便统一自己的多个开发环境。</li>
<li>本机的特殊配置</li>
</ol>
<p>默认的配置永远不要去修改，自己的款平台配置可以放入到fork系列文件中，比如 .vimrc.before.fork   .vimrc.bundles.fork  .vimrc.fork。本地的特殊配置则应当写入local文件中，比如：.vimrc.before.local，.vimrc.bundles.local，.vimrc.local</p>
<p>所有配置文件的加载顺序是：</p>
<pre><code>.vimrc.before - spf13-vim before configuration
.vimrc.before.fork - fork before configuration
.vimrc.before.local - before user configuration
.vimrc.bundles - spf13-vim bundle configuration
.vimrc.bundles.fork - fork bundle configuration
.vimrc.bundles.local - local user bundle configuration
.vimrc - spf13-vim vim configuration
.vimrc.fork - fork vim configuration
.vimrc.local - local user configuration</code></pre><p>spf-vim 可以理解在对原来插件系统的增强，原本vim的启动可以看成是：加载用户配置，和根据用户配置加载插件的过程。但是，原来用户配置和插件比较混乱，不好管理。新的spf-vim仅仅是梳理了这个过程，将整个过程分为：初始化，对插件的管理，配置3个过程。 初始化可以影响插件系统，插件系统处理完了，最后再进行配置。</p>
<p>有了以上的的理解，就可以知道，.vimrc.before系列配置文件一般用来对插件进行管理，比如插件有分组，可以指定加载某个组的插件，或者全局性的配置。.vimrc.bundles主要影响vundles插件系统的参数，一般增加插件，卸载插件可以放在这里。.vimrc系列则可以配置具体某个插件的操作习惯等。</p>
<p>具体来说，指定加载某组插件，可以是如下的命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo let g:spf13_bundle_groups&#x3D;[\&#39;general\&#39;, \&#39;programming\&#39;, \&#39;misc\&#39;, \&#39;youcompleteme\&#39;] &gt;&gt; .vimrc.before.fork</span><br></pre></td></tr></table></figure>

<p>新增插件可以是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo Bundle \&#39;spf13&#x2F;vim-colors\&#39; &gt;&gt; ~&#x2F;.vimrc.bundles.local</span><br></pre></td></tr></table></figure>

<p>卸载插件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo UnBundle \&#39;AutoClose\&#39; &gt;&gt; ~&#x2F;.vimrc.bundles.local</span><br><span class="line">echo UnBundle \&#39;scrooloose&#x2F;syntastic\&#39; &gt;&gt; ~&#x2F;.vimrc.bundles.local</span><br></pre></td></tr></table></figure>

<p>具体.fork，.local文件可以设置哪些参数，可以去对象的默认文件中查看。 使用<code>&lt;Leader&gt;ev</code>可以打开配置，<code>&lt;Leader&gt;sv</code>可以保存配置。</p>
<h2 id="按键配置知识。"><a href="#按键配置知识。" class="headerlink" title="按键配置知识。"></a>按键配置知识。</h2><p><Leader>表示前置键，这里默认是<code>,</code>，可以有<Leader><Leader>r 这种多个前置键的用法。</p>
<p>vim有三种模式，普通模式，插入模式，visual模式。对应的，每一个按键组合，在不同的模式下可以有不同的功能。也就是说，可以在不同模式下的不同使用目的映射到同一个按键组合。</p>
<p>还有另外一个知识，就是映射能不能递归。默认按键映射是递归的，如果映射前加了nore前缀，就表示这个按键不进行递归处理。递归就是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:map j gg</span><br><span class="line">:map Q j</span><br><span class="line">:noremap W j</span><br></pre></td></tr></table></figure>
<p>Q就映射到了gg，W映射到j而不是gg。</p>
<p>映射会见到如下的写法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vnoremap</span><br><span class="line">vmap</span><br><span class="line">map</span><br><span class="line">noremap</span><br><span class="line">imap</span><br><span class="line">inoremap</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建自己的科学上网环境</title>
    <url>/2019/04/08/%E5%85%B6%E5%AE%83/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<p>日常使用过程中或多或少都需要访问国外的一些网站，购买的商业的VPN或者科学上网方案总是存在稳定性问题，最后还是决定自己购买VPS服务器，自己搭建一个梯子更加稳定也更加经济。<a id="more"></a> </p>
<h1 id="购买VPS"><a href="#购买VPS" class="headerlink" title="购买VPS"></a>购买VPS</h1><p>考虑了两家国外的VPS提供商，一个是搬瓦工，另外一个是Vultr。考虑到搬瓦工现在也不便宜了，而且必须要按年付费，最终还是决定使用Vultr的产品，按小时来计费的VPS。</p>
<p>购买过程就不说了，这个没什么难度。新用户注册，有充10送50的活动，注意有注册链接的限制。只有在创建一个设备后，vultr才会收费。对于我，只有搭建梯子这样一个需求，因此选择最便宜的方案，服务器地点选择了东京、西雅图、芝加哥都行。创建后，可以随时销毁，因此也可以不断的尝试不同地点的服务器，选择一个延迟最低的方案。注意，只有销毁后才会停止收费，仅仅停止服务器是不会停止收费的。</p>
<p>创建服务器之后，根据页面显示的信息，就可以使用ssh来登录服务器了。后面所有的操作、配置都是通过ssh来完成的。我自己常用的ssh客户端是SecureCRT。首次登录后，可以更改密码，改为自己好输入的一个密码。</p>
<h1 id="安装SSR服务器"><a href="#安装SSR服务器" class="headerlink" title="安装SSR服务器"></a>安装SSR服务器</h1><p>使用如下命令来下载SSR服务器相关脚本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget --no-check-certificate https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;teddysun&#x2F;shadowsocks_install&#x2F;master&#x2F;shadowsocksR.sh</span><br></pre></td></tr></table></figure>
<p>等待成功后，再输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod +x shadowsocksR.sh</span><br><span class="line">.&#x2F;shadowsocksR.sh 2&gt;&amp;1 | tee shadowsocksR.log</span><br></pre></td></tr></table></figure>
<p>若是正常的话，接下来就是配置SSR服务器的提示了，按照提示进行选择即可。我这里的配置如下：</p>
<ol>
<li>端口号：17136</li>
<li>加密方式：chacha20</li>
<li>协议：auth_sha1_v4</li>
<li>混淆：tls1.2_ticket_auth</li>
</ol>
<p>按照提示按任意键就开始了真正的部署Shadowsocks了，我们等待部署结束后就会看到我们所部署的 Shadowsocks 的配置信息。我们需要记下Shadowsocks的配置信息：服务器IP（Sever IP ）、服务器端口号（Serer Port）、登录密码（Password）和加密方式（Encryption Method）。</p>
<h1 id="开启BBR加速"><a href="#开启BBR加速" class="headerlink" title="开启BBR加速"></a>开启BBR加速</h1><p>下载</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget --no-check-certificate https:&#x2F;&#x2F;github.com&#x2F;teddysun&#x2F;across&#x2F;raw&#x2F;master&#x2F;bbr.sh</span><br></pre></td></tr></table></figure>
<p>然后</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod +x bbr.sh</span><br><span class="line">.&#x2F;bbr.sh</span><br></pre></td></tr></table></figure>
<p>接着按任意键，开始安装，坐等一会。安装完成一会之后它会提示我们是否重新启动vps，我们输入 y 确定重启服务器。重新启动之后，输入 <code>lsmod | grep bbr</code> 如果看到 tcp_bbr 就说明 BBR 已经启动了。</p>
]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>科学上网</tag>
      </tags>
  </entry>
  <entry>
    <title>appWeb使用</title>
    <url>/2020/05/20/Linux/arm/appWeb%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="Windows平台上的编译和运行"><a href="#Windows平台上的编译和运行" class="headerlink" title="Windows平台上的编译和运行"></a>Windows平台上的编译和运行</h2><p>先下载MakeMe配置工具，然后在命令行中执行一下两条命令即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">me configure</span><br><span class="line">me</span><br></pre></td></tr></table></figure>

<p>创建保存appWeb资料的目录，将生成的目录下的全部文件拷贝到目录中，这里我创建了<code>d:\dev\appWeb</code>目录下，并目录添加到PATH路径中。 另外创建存放网站资源的根目录 <code>d:\dev\www</code></p>
<p>在命令行中运行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">appweb D:\dev\www</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://www.embedthis.com/appweb/doc/" target="_blank" rel="noopener">官方文档</a></li>
<li><a href="https://blog.csdn.net/longbei9029/article/details/79388982" target="_blank" rel="noopener">https://blog.csdn.net/longbei9029/article/details/79388982</a></li>
<li><a href="https://blog.csdn.net/xiaominthere/article/details/38756421" target="_blank" rel="noopener">https://blog.csdn.net/xiaominthere/article/details/38756421</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
        <category>arm</category>
      </categories>
      <tags>
        <tag>appWeb</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>dropbear使用和配置</title>
    <url>/2019/01/23/Linux/arm/dropbear%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>嵌入式中提供ssh服务的通常是使用dropbear</p>
<h2 id="更改端口号和只允许某个网卡连接"><a href="#更改端口号和只允许某个网卡连接" class="headerlink" title="更改端口号和只允许某个网卡连接"></a>更改端口号和只允许某个网卡连接</h2><p>在/etc/default/dropbear 中添加条目<code>DROPBEAR_PORT=10022</code>就能更改ssh服务的端口号为10022。</p>
<p>在某些特殊情况下，对于有两个2网卡的设备，可能需要限制只能通过某一个网卡来进行ssh登录。假设网卡1IP地址是<code>192.168.0.206</code>,假设网卡2的IP地址是<code>192.168.1.136</code>。如果只允许通过网卡1来连接，可以设置<code>DROPBEAR_PORT=192.168.0.206:10022</code>。</p>
<h2 id="客户端免密登录"><a href="#客户端免密登录" class="headerlink" title="客户端免密登录"></a>客户端免密登录</h2><p>假设有两台设备，一个是设备A，可能是个windows系统。另外一台是服务器S。 以两种情况下的来实现从设备A免密登录服务器B的原理。</p>
<h3 id="常规Linux服务器免密登录"><a href="#常规Linux服务器免密登录" class="headerlink" title="常规Linux服务器免密登录"></a>常规Linux服务器免密登录</h3><p>常规Linux服务器安装的是OpenSSH套件，配置的方式如下：</p>
<ol>
<li><p>在A设备上，生成公钥、私钥。</p>
<p> ssh-keygen -t rsa    </p>
</li>
<li><p>必须要将公钥放入到S的.ssh/authorized_keys 文件中。</p>
</li>
</ol>
<p>一种方式是通过ssh-copy-id拷贝到服务器S上，命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-copy-id -i ~&#x2F;.ssh&#x2F;id_rsa.pub root@192.168.1.136</span><br></pre></td></tr></table></figure>

<p><code>ssh-copy-id</code>命令可以把本地主机的公钥复制到远程主机的<code>authorized_keys</code>文件上，<code>ssh-copy-id</code>命令也会给远程主机的用户主目录<code>（home）</code>和<code>~/.ssh</code>, 和<code>~/.ssh/authorized_keys</code>设置合适的权限。</p>
<p>另外一种是手动将公钥文件重命名拷贝到.ssh/authorized_keys中。</p>
<ol start="3">
<li>设备A上的私钥管理</li>
</ol>
<p>如果默认私钥放在.ssh 下，那么ssh命令在连接所有设备会自动的尝试读取。因此自然就能用来登录设备S。</p>
<p>如果需要指定在登录某些设备使用哪个私钥，可以在.ssh/目录下添加config文件。</p>
<p>也可以在使用ssh命令时，手动指定要使用的私钥文件。</p>
<p><strong>注意：需要注意的是，需要将.ssh/id_rsa权限设置为700</strong></p>
<ol start="4">
<li>如果使用putty，plink等工具来自动登录设备，还需要对生成的id_rsa进行转换，转成putty工具能识别的私钥文件。</li>
</ol>
<p>打开puttygen，点击加载。加载id_rsa文件，然后再点击保存私钥文件，就能保存成putty能使用的文件，成功的文件已ppk后缀结尾。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">putty.exe -ssh root@192.168.10.106 -i h:\device.ppk</span><br></pre></td></tr></table></figure>

<h3 id="使用dropbear的嵌入式免密登录"><a href="#使用dropbear的嵌入式免密登录" class="headerlink" title="使用dropbear的嵌入式免密登录"></a>使用dropbear的嵌入式免密登录</h3><p>其实可以忽略设备是使用dropbear还是openssh，针对服务器的所有操作一样，关键点就是将公钥放入到服务器的.ssh/authorized_keys。</p>
<h2 id="不可忽略的关键点"><a href="#不可忽略的关键点" class="headerlink" title="不可忽略的关键点"></a>不可忽略的关键点</h2><p>因为本身使用ssh就是针对关于安全方面，所以，关于能否免密登录的核心关键点就是权限，比如 authorized_keys 文件的权限，必须设置成700。对于嵌入式设备来说，还必须关注文件的拥有者问题。</p>
<p>因为嵌入式设备的文件系统基本上都是在HOST机器上处理，并打包的。因此，烧写到设备后，可能会发现文件的拥有者莫名奇妙。通常，嵌入式设备只有一个用户，就是root用户。因此，需要特别注意处理文件系统中文件的拥有者问题。</p>
<p>实际测试发现，如果文件拥有者属性不对，设备将不支持免密登录功能。</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>arm</category>
      </categories>
      <tags>
        <tag>ssh</tag>
        <tag>dropbear</tag>
      </tags>
  </entry>
  <entry>
    <title>goahead使用笔记</title>
    <url>/2020/05/20/Linux/arm/gohead%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="嵌入式web服务器的选择"><a href="#嵌入式web服务器的选择" class="headerlink" title="嵌入式web服务器的选择"></a>嵌入式web服务器的选择</h2><h3 id="cgi"><a href="#cgi" class="headerlink" title="cgi"></a>cgi</h3><p>作为一个web服务器，仅仅是提供静态的网页内容肯定是不够的。对于嵌入式来说，基本上是通过cgi来扩展web服务器，用来提供内容。web服务器会监测到用户在浏览器中的一些动作，通常是POST，GET（对应用户的操作就是刷新、点击提交等动作），这些动作会绑定到某个cgi程序来处理。</p>
<p>传统用C做CGI的方法是直接使用printf() 等标准I/O函数输出HTML代码。</p>
<p>CGI是一种提供动态生成网页的概念，除了传统的用C来实现，也有其它的类似的技术。其中有一种JSP的技术，Servlet是Java技术对CGI编程的回答。Servlet程序在服务器端运行，动态地生成Web页面。与传统的CGI和许多其他类似CGI的技术相比，Servlet具有更高的效率，更容易使用，功能更强大，具有更好的可移植性，更节省投资。JSP是强于CGI，这也是现在CGI技术的使用没有JSP使用多的原因。但现在嵌入式web服务器端程序开发，还是CGI较多。由于使用JSP技术，在嵌入式web服务器开发中很少使用，在网上没有查到关于在嵌入式web服务器上应用的有关内容。</p>
<p>综合比较了thttpd，boa，goahead等适用于嵌入式设备上的web服务器，最终还是选择了goahead，因为它的功能功能强大，支持javascript，asp。不像其它的，只支持cgi。</p>
<p>考虑到使用范围宽广程度，在小型服务器、不要求太强功能，推荐选用boa、thttpd，其实它们足可以满足大多数情况下的需求，也是使用最广、可参考最多的嵌入式web服务器。如果要求强大的功能，支持javastript等，推荐选用goahead、appweb。</p>
<p>CGI相关概念:<br><a href="https://www.jianshu.com/p/c4dc22699a42" target="_blank" rel="noopener">https://www.jianshu.com/p/c4dc22699a42</a><br><a href="https://zhuanlan.zhihu.com/p/25013398" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/25013398</a><br><a href="https://blog.csdn.net/weixin_39609623/article/details/86312439" target="_blank" rel="noopener">https://blog.csdn.net/weixin_39609623/article/details/86312439</a></p>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>修改源码，因为是嵌入式设备使用，通常设备可能并没有连接到公网。无法解析hostname得到ip地址。需要修改src/http.c 文件中的源码，修改的地方参考网上的内容。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#if 0</span><br><span class="line">    	struct hostent  *hp;</span><br><span class="line">    	if ((hp &#x3D; gethostbyname(host)) &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">        	error(&quot;Cannot get host address for host %s: errno %d&quot;, host, errno);</span><br><span class="line">        	return -1;</span><br><span class="line">    	&#125;</span><br><span class="line">    	memcpy((char*) &amp;intaddr, (char *) hp-&gt;h_addr_list[0], (size_t) hp-&gt;h_length);</span><br><span class="line">    	ipaddr &#x3D; inet_ntoa(intaddr);</span><br><span class="line">    #else		</span><br><span class="line">    	&#x2F;* new add *&#x2F;</span><br><span class="line">		int sockfd;</span><br><span class="line">		struct sockaddr_in sin;</span><br><span class="line">		struct ifreq ifr;</span><br><span class="line">		sockfd &#x3D; socket(AF_INET, SOCK_DGRAM, 0);</span><br><span class="line">		if(sockfd &#x3D;&#x3D; -1)</span><br><span class="line">		&#123;</span><br><span class="line">			error(&quot;get socket error!\n&quot;);</span><br><span class="line">			return -1;</span><br><span class="line">		&#125;</span><br><span class="line">		strncpy(ifr.ifr_name, &quot;eth0&quot;, IFNAMSIZ);</span><br><span class="line">		ifr.ifr_name[IFNAMSIZ-1]&#x3D;0;</span><br><span class="line">		if(ioctl(sockfd, SIOCGIFADDR, &amp;ifr)&lt;0)</span><br><span class="line">		&#123;</span><br><span class="line">			error(&quot;ioctl error!\n&quot;);</span><br><span class="line">			return -1;</span><br><span class="line">		&#125;</span><br><span class="line">		memcpy(&amp;sin, &amp;ifr.ifr_addr, sizeof(sin));</span><br><span class="line">		ipaddr &#x3D; inet_ntoa(sin.sin_addr);</span><br><span class="line">    #endif</span><br></pre></td></tr></table></figure>
<p>上面 被注释掉的部分就是修改前的，#else部分就是修改后的。</p>
<p>修改完后，交叉编译主要指定CC和ARCH两个变量。使用如下的命令来交叉编译：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source &#x2F;opt&#x2F;arm49&#x2F;env.sh</span><br><span class="line">make</span><br></pre></td></tr></table></figure>

<p>交叉编译之后，在build/linux-arm-default/bin目录有生成的相关文件。</p>
<pre><code>也可以不修改源码，编译完毕，部署到设备之后，运行会提示无法解析myimx6ek314这个hostnamne。只需要修改/etc/hosts，添加一条解析myimx6ek314到127.0.0.1的记录即可。</code></pre><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>生成的bin目录下的文件有：<br>ca.crt  ec.crt  goahead       gopass    libgoahead-mbedtls.a  roots.crt  self.key  test.key<br>ca.key  ec.key  goahead-test  libgo.so  libmbedtls.a          self.crt   test.crt </p>
<ol>
<li><p>goahead、goahead-test、gopass放到设备的/usr/bin/目录下。</p>
</li>
<li><p>libgoahead-mbedtls.a ibmbedtls.a 文件可以删除。</p>
</li>
<li><p>其它文件拷贝到 /etc/goahead 目录下。</p>
</li>
<li><p>另外将src/route.txt src/auth.txt 拷贝到 /etc/goahead 目录下。</p>
</li>
<li><p>创建目录/var/www 作为存放网页资源的目录。创建一个index.html 页面放入/var/www作为测试用。</p>
</li>
</ol>
<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>使用如下的命令来运行goahead</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">goahead  -v --home &#x2F;etc&#x2F;goahead &#x2F;var&#x2F;www 0.0.0.0:80</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.embedthis.com/goahead/doc/start/running.html" target="_blank" rel="noopener">https://www.embedthis.com/goahead/doc/start/running.html</a><br><a href="https://www.embedthis.com/makeme/doc/source/make.html" target="_blank" rel="noopener">https://www.embedthis.com/makeme/doc/source/make.html</a><br><a href="https://www.embedthis.com/goahead/doc/users/" target="_blank" rel="noopener">https://www.embedthis.com/goahead/doc/users/</a></p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>arm</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>goagead</tag>
      </tags>
  </entry>
  <entry>
    <title>编写shell脚本</title>
    <url>/2020/05/20/Linux/shell/%E7%BC%96%E5%86%99shell%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<p>Shell脚本中的命令会按照书写顺序串行执行，但是默认不对shell执行行为进行配置的话，即使某一条语句失败，下一条语句还是会接着执行。要控制这种行为有两种方式，一种是在脚本开始用<code>set -e</code>，另外一种是将需要保证执行成功的命令用<code>&amp;&amp;</code>连接起来。<br>建议在脚本的开头添加如下的内容。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 设置shell脚本的执行方式</span><br><span class="line">set -e #若指令传回值不等于0，则立即退出shell </span><br><span class="line">set -u #当执行时使用到未定义过的变量，则显示错误信息</span><br><span class="line">set -o pipefail #表示在管道连接的命令序列中，只要有任何一个命令返回非0值，则整个管道返回非0值，即使最后一个命令返回0.</span><br><span class="line">#set -x #执行指令后，会先显示该指令及所下的参数，调试时可以打开这个。</span><br></pre></td></tr></table></figure>

<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>shell变量是一种很“弱”的变量，默认情况下，一个变量保存一个串，shell不关心这个串是什么含义。所以若要进行数学运算，必须使用一些命令例如let、declare、expr、双括号等。shell变量可分为两类：局部变量和环境变量。局部变量只在创建它们的shell中可用。而环境变量则可以在创建它们的shell及其派生出来的任意子进程中使用。有些变量是用户创建的，其他的则是专用shell变量。变量名必须以字母或下划线字符开头。其余的字符可以是字母、数字(0~9)或下划线字符。任何其他的字符都标志着变量名的终止。名字是大小写敏感的。给变量赋值时，等号周围不能有任何空白符。为了给变量赋空值，可以在等号后跟一个换行符。用set命令可以查看所有的变量，unset var命令可以清除变量var，var相当于没有定义过。readonly var可以把var变为只读变量，定义之后不能对var进行任何更改。对shell变量的引用方式很多，用这些方式可以方便的获取shell变量的值，变量值的长度，变量的一个字串，变量被部分替换后的值等等。shell变量常见引用方式如下：<br><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://i.loli.net/2020/06/01/eJuV3yXnQaHAgl4.png" alt="linux_shell_variable_table1.png"></p>
<h2 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h2><ol>
<li>跟执行命令有关的是：反引号、小括号（）、大括号{}</li>
<li>跟条件表达式有关的是：双括号（用于整数的判断）、双中括号[[]]（能直接使用&amp;&amp; ||等符号）、中括号[]（不能使用&amp;&amp; || &lt; &gt; 等）</li>
<li>用于变量内容处理、字符串处理的是：大括号{}</li>
</ol>
<h3 id="反引号、双引号、单引号"><a href="#反引号、双引号、单引号" class="headerlink" title="反引号、双引号、单引号"></a>反引号、双引号、单引号</h3><pre><code>反引号``是命令替换，命令替换是指Shell可以先执行``中的命令，得到输出结果。语法:`command`
变量中间有空格的问题，双引号&quot;&quot;则对于双引号&quot;&quot;内的变量和参数会展开，包括对反引号中命令的替换。
单引号&apos;&apos;剥夺了所有字符的特殊含义,单引号&apos;&apos;内的内容就变成了单纯的字符。</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line">DATE&#x3D;&#96;date&#96;</span><br><span class="line">echo &quot;Date is $DATE&quot;</span><br><span class="line"></span><br><span class="line">USERS&#x3D;&#96;who | wc -l&#96;</span><br><span class="line">echo &quot;Logged in user are $USERS&quot;</span><br><span class="line"></span><br><span class="line">UP&#x3D;&#96;date ; uptime&#96;</span><br><span class="line">echo &quot;Uptime is $UP&quot;</span><br></pre></td></tr></table></figure>

<h3 id="单小括号"><a href="#单小括号" class="headerlink" title="单小括号 ()"></a>单小括号 ()</h3><ol>
<li><p>命令组。括号中的命令将会新开一个子shell顺序执行，所以括号中的变量不能够被脚本余下的部分使用。括号中多个命令之间用分号隔开，最后一个命令可以没有分号，各命令和括号之间不必有空格。</p>
</li>
<li><p>命令替换。等同于<code>cmd</code>，shell扫描一遍命令行，发现了$(cmd)结构，便将$(cmd)中的cmd执行一次，得到其标准输出，再将此输出放到原来命令。有些shell不支持，如tcsh。</p>
</li>
<li><p>用于初始化数组。如：array=(a b c d)</p>
</li>
</ol>
<h3 id="双小括号"><a href="#双小括号" class="headerlink" title="双小括号 (( ))"></a>双小括号 (( ))</h3><ol>
<li><p>整数扩展。这种扩展计算是整数型的计算，不支持浮点型。((exp))结构扩展并计算一个算术表达式的值，如果表达式的结果为0，那么返回的退出状态码为1，或者 是”假”，而一个非零值的表达式所返回的退出状态码将为0，或者是”true”。若是逻辑判断，表达式exp为真则为1,假则为0。</p>
</li>
<li><p>只要括号中的运算符、表达式符合C语言运算规则，都可用在$((exp))中，甚至是三目运算符。作不同进位(如二进制、八进制、十六进制)运算时，输出结果全都自动转化成了十进制。如：echo $((16#5f)) 结果为95 (16进位转十进制)</p>
</li>
<li><p>单纯用 (( )) 也可重定义变量值，比如 a=5; ((a++)) 可将 $a 重定义为6</p>
</li>
<li><p>常用于算术运算比较，双括号中的变量可以不使用$符号前缀。括号内支持多个表达式用逗号分开。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">只要括号中的表达式符合C语言运算规则,比如可以直接使用for((i&#x3D;0;i&lt;5;i++))&#96;, </span><br><span class="line">如果不使用双括号, 则为for i in &#96;seq 0 4&#96;或者for i in &#123;0..4&#125;。</span><br><span class="line">再如可以直接使用if (($i&lt;5)), 如果不使用双括号, 则为if [ $i -lt 5 ]。</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="单中括号"><a href="#单中括号" class="headerlink" title="单中括号 []"></a>单中括号 []</h3><ol>
<li><p>bash 的内部命令，[和test是等同的。如果我们不用绝对路径指明，通常我们用的都是bash自带的命令。if/test结构中的左中括号是调用test的命令标识，右中括号是关闭条件判断的。这个命令把它的参数作为比较表达式或者作为文件测试，并且根据比较的结果来返回一个退出状态码。if/test结构中并不是必须右中括号，但是新版的Bash中要求必须这样。</p>
</li>
<li><p>Test和[]中可用的比较运算符只有==和!=，两者都是用于字符串比较的，不可用于整数比较，整数比较只能使用-eq，-gt这种形式。无论是字符串比较还是整数比较都不支持大于号小于号。如果实在想用，对于字符串比较可以使用转义形式，如果比较”ab”和”bc”：[ ab &lt; bc ]，结果为真，也就是返回状态为0。[ ]中的逻辑与和逻辑或使用-a 和-o 表示。</p>
</li>
<li><p>字符范围。用作正则表达式的一部分，描述一个匹配的字符范围。作为test用途的中括号内不能使用正则。</p>
</li>
<li><p>在一个array 结构的上下文中，中括号用来引用数组中每个元素的编号。</p>
</li>
</ol>
<h3 id="双中括号"><a href="#双中括号" class="headerlink" title="双中括号[[ ]]"></a>双中括号[[ ]]</h3><ol>
<li><p>[[是 bash 程序语言的关键字。并不是一个命令，[[ ]] 结构比[ ]结构更加通用。在[[和]]之间所有的字符都不会发生文件名扩展或者单词分割，但是会发生参数扩展和命令替换。</p>
</li>
<li><p>支持字符串的模式匹配，使用=~操作符时甚至支持shell的正则表达式。字符串比较时可以把右边的作为一个模式，而不仅仅是一个字符串，比如[[ hello == hell? ]]，结果为真。[[ ]] 中匹配字符串或通配符，不需要引号。</p>
</li>
<li><p>使用[[ … ]]条件判断结构，而不是[ … ]，能够防止脚本中的许多逻辑错误。比如，&amp;&amp;、||、&lt;和&gt; 操作符能够正常存在于[[ ]]条件判断结构中，但是如果出现在[ ]结构中的话，会报错。比如可以直接使用if [[ $a != 1 &amp;&amp; $a != 2 ]], 如果不适用双括号, 则为if [ $a -ne 1] &amp;&amp; [ $a != 2 ]或者if [ $a -ne 1 -a $a != 2 ]。</p>
</li>
<li><p>bash把双中括号中的表达式看作一个单独的元素，并返回一个退出状态码。</p>
</li>
</ol>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if ($i&lt;5) </span><br><span class="line">if [ $i -lt 5 ] </span><br><span class="line">if [ $a -ne 1 -a $a !&#x3D; 2 ] </span><br><span class="line">if [ $a -ne 1] &amp;&amp; [ $a !&#x3D; 2 ] </span><br><span class="line">if [[ $a !&#x3D; 1 &amp;&amp; $a !&#x3D; 2 ]] </span><br><span class="line">for i in $(seq 0 4);do echo $i;done </span><br><span class="line">for i in &#96;seq 0 4&#96;;do echo $i;done </span><br><span class="line">for ((i&#x3D;0;i&lt;5;i++));do echo $i;done </span><br><span class="line">for i in &#123;0..4&#125;;do echo $i;done</span><br></pre></td></tr></table></figure>

<h3 id="大括号"><a href="#大括号" class="headerlink" title="大括号{}"></a>大括号{}</h3><ol>
<li><p>大括号拓展。(通配(globbing))将对大括号中的文件名做扩展。在大括号中，不允许有空白，除非这个空白被引用或转义。第一种：对大括号中的以逗号分割的文件列表进行拓展。如 touch {a,b}.txt 结果为a.txt b.txt。第二种：对大括号中以点点（..）分割的顺序文件列表起拓展作用，如：touch {a..d}.txt 结果为a.txt b.txt c.txt d.txt</p>
</li>
<li><p>代码块，又被称为内部组，这个结构事实上创建了一个匿名函数 。与小括号中的命令不同，大括号内的命令不会新开一个子shell运行，即脚本余下部分仍可使用括号内变量。括号内的命令间用分号隔开，最后一个也必须有分号。{}的第一个命令和左括号之间必须要有一个空格。</p>
</li>
<li><p>处理变量的内容</p>
</li>
<li><p>处理字符串的内容</p>
</li>
</ol>
<h2 id="传递命令行参数"><a href="#传递命令行参数" class="headerlink" title="传递命令行参数"></a>传递命令行参数</h2><p>脚本内获取参数的格式为：$n。n 代表一个数字，1 为执行脚本的第一个参数，2 为执行脚本的第二个参数，以此类推。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">echo &quot;执行的文件是：$0&quot;</span><br><span class="line">echo &quot;第一个参数: $1&quot;</span><br><span class="line">echo &quot;第二个参数：$2&quot;</span><br><span class="line">echo &quot;第三个参数：$3&quot;</span><br><span class="line">echo &quot;传递的参数个数： $#&quot;</span><br><span class="line">echo &quot;以一个单字符串显示所有向脚本传递的参数: $*&quot;</span><br><span class="line">echo &quot;脚本运行的当前进程ID号: $$&quot;</span><br><span class="line">echo &quot;后台运行的最后一个进程的ID号： $!&quot;</span><br><span class="line">echo &quot;是使用时加引号，并在引号中返回每个参数：$@&quot;</span><br><span class="line">echo &quot;显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误: $?&quot;</span><br></pre></td></tr></table></figure>

<p><code>$*</code> 与 <code>$@</code> 是两个特别的变量。他们的区别是：</p>
<ul>
<li>相同点：都是引用所有参数。</li>
<li>不同点：只有在双引号中体现出来。假设在脚本运行时写了三个参数 1、2、3，，则 “ * “ 等价于 “1 2 3”（传递了一个参数），而 “@” 等价于 “1” “2” “3”（传递了三个参数）</li>
</ul>
<h2 id="条件判断表达式"><a href="#条件判断表达式" class="headerlink" title="条件判断表达式"></a>条件判断表达式</h2><h3 id="数值判断"><a href="#数值判断" class="headerlink" title="数值判断"></a>数值判断</h3><ol>
<li>-eq 等于则为真。</li>
<li>-ne 不等于则为真。</li>
<li>-gt 大于则为真。</li>
<li>-ge 大于等于则为真。</li>
<li>-lt 小于则为真。</li>
<li>-le 小于等于则为真。</li>
</ol>
<h3 id="文件相关"><a href="#文件相关" class="headerlink" title="文件相关"></a>文件相关</h3><ol>
<li>-e文件名 如果文件存在则为真。</li>
<li>-r文件名 如果文件存在且可读则为真。</li>
<li>-w文件名 如果文件存在且可写则为真。</li>
<li>-x文件名 如果文件存在且可执行则为真。</li>
<li>-s文件名 如果文件存在且至少有一个字符则为真。</li>
<li>-d文件名 如果文件存在且为目录则为真。</li>
<li>-f文件名 如果文件存在且为普通文件则为真。</li>
<li>-c文件名 如果文件存在且为字符型特殊文件则为真。</li>
<li>-b文件名 如果文件存在且为块特殊文件则为真</li>
</ol>
<h2 id="各种符号"><a href="#各种符号" class="headerlink" title="各种符号"></a>各种符号</h2><h3 id="amp-amp-符号"><a href="#amp-amp-符号" class="headerlink" title="&amp;&amp;符号"></a>&amp;&amp;符号</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">command1 &amp;&amp; command2 &amp;&amp; command3 ...</span><br></pre></td></tr></table></figure>
<ol>
<li>命令之间使用 &amp;&amp; 连接，实现逻辑与的功能。</li>
<li>只有在 &amp;&amp; 左边的命令返回真（命令返回值 $? == 0），&amp;&amp; 右边的命令才会被执行。</li>
<li>只要有一个命令返回假（命令返回值 $? == 1），后面的命令就不会被执行。</li>
</ol>
<h2 id="特别注意点"><a href="#特别注意点" class="headerlink" title="特别注意点"></a>特别注意点</h2><ol>
<li>if语句的[]不能紧接着变量，必须要有一个空格。</li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>CMake变量的使用</title>
    <url>/2019/06/07/cpp/CMake/CMake%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>C++</category>
        <category>cmake</category>
      </categories>
      <tags>
        <tag>cmake</tag>
      </tags>
  </entry>
  <entry>
    <title>从实例学习CMake(1)</title>
    <url>/2019/06/07/cpp/CMake/CMake%E5%AE%9E%E4%BE%8B1/</url>
    <content><![CDATA[<p>本系列实例教程有大部分来自于官方的教程，另外部分来自于自己的项目实践。</p>
<h2 id="示例工程介绍"><a href="#示例工程介绍" class="headerlink" title="示例工程介绍"></a>示例工程介绍</h2><h2 id="关键点展示"><a href="#关键点展示" class="headerlink" title="关键点展示"></a>关键点展示</h2><h2 id="完整CMakeLists-txt展示"><a href="#完整CMakeLists-txt展示" class="headerlink" title="完整CMakeLists.txt展示"></a>完整CMakeLists.txt展示</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>]]></content>
      <categories>
        <category>C++</category>
        <category>cmake</category>
      </categories>
      <tags>
        <tag>cmake</tag>
      </tags>
  </entry>
  <entry>
    <title>Poco字符相关处理</title>
    <url>/2018/06/23/cpp/Poco/Poco%E5%AD%97%E7%AC%A6%E7%9B%B8%E5%85%B3%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p>Poco提供了统一的处理字符串的相关接口，熟练使用它很多时候能方便的实现功能。</p>
<a id="more"></a> 

<h1 id="字符串相关处理"><a href="#字符串相关处理" class="headerlink" title="字符串相关处理"></a>字符串相关处理</h1><ol>
<li>Poco并没有提供一个通用的字符串类，仅仅在Poco/String.h函数中提供了一些扩张的处理string/wstring的方法。</li>
<li>Poco对于非ASCII的转换并不提供的一键式的解决方案，需要另外的第三方方案(比如ICU)</li>
<li>Poco::NumberFormatter 提供从整型到字符的转换</li>
<li>Poco::NumberParser  提供从字符串到各种整型的分析。</li>
<li>format 支持直接到string的格式化</li>
<li>Poco::StringTokenizer 可以将一串字符分解成多个字串</li>
<li>Poco::RegularExpression 提供对正则表达式的支持</li>
</ol>
<h1 id="字符编码转换"><a href="#字符编码转换" class="headerlink" title="字符编码转换"></a>字符编码转换</h1><ol>
<li><p>Poco::TextConverter 支持在 ASCII, Latin-1, Latin-9, Windows-1252, UTF-8 and UTF-16 之间的互相转换</p>
</li>
<li><p>在TextConverter的转换过程中，首先通过对源字符串的迭代器，在指定源编码格式的信息下得到一个个字符对应的Unicode码，然后再通过目标编码的函数，将Unicode码转换到具体的编码。</p>
</li>
<li><p>TextConverter的转换过程严重依赖具体的编码方案，要求编码方案提供如下的两个接口：</p>
<ul>
<li>检测一段字节序列，返回字节序列的对应的Unicode码位值，函数queryConvert</li>
<li>将Unicode码位值转换成一段字节序列，convet</li>
</ul>
</li>
<li><p>TextEncoding类代表一种具体的编码方案，其必须提供查询、字节序列转Unicode码位和Unicode码位转字节序列</p>
</li>
<li><p>TextEncodingManager 单例类，管理所有注册的编码类，支持按名字查找等功能，主要时为了使用方便。对于很明确知道具体的编码类名字的，无需使用到它。</p>
</li>
<li><p>每种Encoding的方法中，都有一个CharacterMap结构，因为每一种多字节编码基本上都是根据第1个码元来确定包含后续多少个码元才能组成一个字符。比如1个UTF-8的字节序列，第1字节大小为C0-CF的话，说明这个UTF-8字符占用2个字节。这个CharacterMap必须是一个码元的后续组成字节数推导表，对UTF-8必须在这个Map中的c0-cf区间返回-2，用来指示第一个字节（UTF-8的一个码元是1个字节）若为c0-cf，这说明本字节开始需要2个字节才能组成一个字符。</p>
</li>
<li><p>Poco::Encodings库中实现了GBK/Latin语系的字符编码到Unicode码位的互转，其实方法就是根据映射表来查表，因为Unicode与Windows代码页所规定的字符之间没有一个转换规则，只有一张表可以对应。因此只能查表。各个文件中，ISO-8859系列是Latin语系编码的国际通用命名，Windows-1520系列是Windows下的Latin语系代码页而已。</p>
</li>
</ol>
<p>一个CharacterMap表，用来查询从前导字节得出以该字符开始的几个字节序列组成一个合法的字符。名称叫做ISO-8859系列的标准，其实都是对单字节编码的统一命名，全是Latin编码系的。<br>    - 一个map，从DBCS编码到Unicode码位的转换表<br>    - 一个reverMap表，从Unicode码位到DBCS编码的转换表</p>
<ol start="7">
<li><p>FoundDataion库也实现了几个编码转换类：ASCIIEncoding、Latin1Encoding、Latin2Encoding、Latin9Encoding、UTF8Encoding、UTF16Encoding、UTF32Encoding</p>
</li>
<li><p>除了提供TextConverter类进行转换外，库还提供OutputStreamConverter、InputStreamConverter提供流式的转换。</p>
</li>
<li><p>Unicode类提供对Unicode单个字符的处理方法、UTF8则提供了对UTF-8字符串的处理方法。</p>
</li>
<li><p>UnicodeConverter提供在UTF-8、UTF-16、UTF-32字符串之间互转的能力</p>
</li>
</ol>
<h1 id="什么时候需要关注这个编码问题"><a href="#什么时候需要关注这个编码问题" class="headerlink" title="什么时候需要关注这个编码问题"></a>什么时候需要关注这个编码问题</h1><p>字符乱码主要表现在如下的几个方面：</p>
<ol>
<li>界面显示乱码，原因包括：程序内部固化字符串采用非Unicode编码的非ASCII字符；程序运行时处理外部的数据读取错误。</li>
<li>外部数据读取主要包括：读取到的文件编码格式问题；通过网络发送过来的数据编码格式问题。</li>
</ol>
<p>程序内部固话字符串的问题好解决：对于Windows只要使用Unicode版本的系统函数即可，不使用多字节版本的系统函数。<br>通过网络发送过来的数据，通常包含各种各样的原始二进制。为保证没有乱码的烦扰，应当对接受到的字符串进行UTF8解析，而发送方应当也只发送UTF8字符串。（对于中文地区来说，只有包含中文时才需要如此）。<br>对于读取自文件，需要知道在对不同的格式的文件时，若是采用文本读取的相关接口，内部到底会怎么处理？</p>
<p>Windows平台：</p>
<ul>
<li>按照文本读取ANSI格式的文档会怎么样？ </li>
<li>按照文本读取UTF8格式的文档会怎么样？</li>
</ul>
<p>这其实跟你用到的函数有关，若使用的string组的函数，它把文档当作时ANSI编码的，当遇到Unicode编码的则会出现乱码。若是使用wstring组的函数，它把文档当作Unicode编码的，总是按照UTF-16的格式来解析的。</p>
<p>若是对于UTF-8的文档，则需要使用string组的接口，读到的内容再转成UTF-8即可。</p>
<p>为了实现跨平台的编码不错乱的问题，按照如下的处理总是没错的：</p>
<ol>
<li>Windows中，涉及到系统层的API总是调用Unicode版本.</li>
<li>所有配置文件都保存成utf8格式，所有业务逻辑相关的处理只用到string，不需要用到wstring，只在需要第1点时转成wstring</li>
<li>所有网络过来的数据都转成utf8格式，通过网络发送出去的数据确保是utf8格式的</li>
<li>对于源码编码格式，建议所有.c/.cpp文件都采用utf8-bom格式，.h/.hpp采用utf8格式（这个不是很理解）</li>
</ol>
<h1 id="ICU库的功能"><a href="#ICU库的功能" class="headerlink" title="ICU库的功能"></a>ICU库的功能</h1><p>对于字符转换相关的功能可以在Poco库中直接给处理了，但是对于各个地区的本地化，比如货币、时间等，还是交给ICU来处理比较好。</p>
]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>字符编码</tag>
        <tag>Poco</tag>
      </tags>
  </entry>
  <entry>
    <title>Application框架</title>
    <url>/2018/05/24/cpp/Poco/Appliction%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h2 id="框架功能"><a href="#框架功能" class="headerlink" title="框架功能"></a>框架功能</h2><p>一个能帮助开发者快速开发的框架必须具有的功能有：从配置文件中读取配置配置，处理命令行参数，作为守护进程运行，日志支持，支持子模块。</p>
<p>Poco应用程序框架抽象出来了两种对象：应用程序和子系统。</p>
<p>应用程序Application代表我们要开发的程序对象，一个应用程序Application可以包含很多个子系统Subsystem。应用程序自己本身也是一个特殊的子系统，必须得实现子系统的接口。当一个Application初始化完成，也就意味着所有的子系统初始化完毕。当Application关闭的时候，所有的子系统也会关闭。可以把子系统当作一个模块来对待。</p>
<h3 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h3><p>使用了框架后，程序的入口最好就不要放在原本的main中了，可以将Application和ServerApplication中的main函数作为入口。声明并定义个Application的子类，实现initialize、uninitialize、reinitialize、main函数，其中main函数为新的程序入口。</p>
<p>为了方便，原本C++的main函数就放入Application的对象创建代码就行，Poco提供了POCO_APP_MAIN(SampleApp)宏来实现这些动作。一个简单的hello world程序demo如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class HelloApplication: public Poco::Util::Application</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">protected:</span><br><span class="line">	void initialize(Application&amp; self)	&#123;</span><br><span class="line">		Application::initialize(self);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	void uninitialize()	&#123;</span><br><span class="line">		Application::uninitialize();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	void reinitialize(Application&amp; self)	&#123;</span><br><span class="line">		Application::reinitialize(self);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	int main(const ArgVec&amp; args)	&#123;</span><br><span class="line">		std::cout &lt;&lt; &quot;hello world!&quot; &lt;&lt; std::endl;</span><br><span class="line">		return Application::EXIT_OK;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">POCO_APP_MAIN(HelloApplication)</span><br></pre></td></tr></table></figure>
<p>执行顺执行时会先执行initialize，然后是main函数，最后是uninitialize</p>
<h2 id="关联配置文件"><a href="#关联配置文件" class="headerlink" title="关联配置文件"></a>关联配置文件</h2><p>Poco框架默认可以会查找4种配置文件：xml格式，ini格式，json格式，properties格式的配置文件，默认配置文件必须跟可执行文件放在同一个目录下，且文件名必须与程序运行文件名相同。应用程序也可以手动加载其它位置的配置文件，而且数量可以是多个，加载时可以指定优先级，数值低的有更大的优先级。</p>
<p>默认配置文件的查找顺序是按照：properties，ini， json，xml的顺序查找，查找到后从，头部开始插入。因此，xml的最优先使用，properties则优先级最低。若参数在xml中存在，也不会使用properties中的参数。</p>
<p>上述的两种加载配置都必须在initialize函数的最开始调用loadConfiguration接口，因为可能其它模块的一些行为也会依赖于配置文件，因此必须要在initialize函数的最开始加载。</p>
<p>Poco框架内部其实使用了一种分层的配置文件框架，每一层的优先级不一样。优先级从-100到100共有200级，值越小优先级越高。loadConfiguration如果不指定配置文件优先级，默认的优先级为0，Poco框架在初始化过程中还会自动添加2个层级的配置。一个是-100级的MapConfiguration，一个是100级的SystemConfiguation。</p>
<p>通过loadConfiguration加载的配置文件，不管是默认位置加载还是手动指定加载位置，配置都是只读的，无法进行修改。因为通过框架加载的配置文件是只读的，因此框架提供了这个-100级的MapConfigureation作为可写的来保存程序运行后界面的配置，但是可惜的是无法将MapConfiguration中的配置直接同步到某个文件。因此，我们如果直接更改参数实际上是更改到这个MapConfiguration的。是无法写入到文件的。</p>
<p>框架还默认提供了一些配置参数在配置文件分层架构中，比如下面这些等等，但是因为这些参数是在运行时才能确定，而且是只读的，因此我们也无需关心这些参数实际是保存在哪个层次的配置对象中。</p>
<pre><code>application.configDir
application.baseName
application.name
application.path
application.cacheDir
application.tempDir
application.dataDir
application.argc
application.argv 

system.osName
system.osVersion
system.osArchitecture
system.nodeName
system.nodeId
system.currentDir
system.cacheHomeDir
system.configHomeDir
system.dataHomeDir
system.tempHomeDir
system.homeDir
system.configDir
system.dateTime
system.pid
system.env</code></pre><h3 id="json配置文件格式"><a href="#json配置文件格式" class="headerlink" title="json配置文件格式"></a>json配置文件格式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;ConfigTest&quot; :	&#123;</span><br><span class="line">       	&quot;item1&quot;: 100,</span><br><span class="line">       	&quot;item2&quot;: &quot;hello&quot;		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Xml配置文件格式"><a href="#Xml配置文件格式" class="headerlink" title="Xml配置文件格式"></a>Xml配置文件格式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;config&gt;</span><br><span class="line">    &lt;ConfigTest&gt;</span><br><span class="line">        &lt;item1 attr1&#x3D;&quot;test&quot;&gt;1&lt;&#x2F;item1&gt;</span><br><span class="line">        &lt;item2&gt;world&lt;&#x2F;item2&gt;</span><br><span class="line">    &lt;&#x2F;ConfigTest&gt;</span><br><span class="line">&lt;&#x2F;config&gt;</span><br></pre></td></tr></table></figure>

<h3 id="Properties配置文件格式"><a href="#Properties配置文件格式" class="headerlink" title="Properties配置文件格式"></a>Properties配置文件格式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ConfigTest.item[0]&#x3D;&quot;hello&quot;</span><br><span class="line">ConfigTest.item[1]&#x3D;&quot;workd&quot;</span><br><span class="line">ConfigTest.a.b.c.d&#x3D;100</span><br></pre></td></tr></table></figure>

<h3 id="写入配置文件"><a href="#写入配置文件" class="headerlink" title="写入配置文件"></a>写入配置文件</h3><p>虽然框架默认加载的配置文件无法直接写，但是我们可以利用具体格式的配置文件对象来写入。比如如下代码，通过新创建一个JSONConfiguration对象来写入到配置文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">std::string configFullPath &#x3D; config().getString(&quot;application.configDir&quot;)  + config().getString(&quot;application.baseName&quot;) + &quot;.json&quot;;</span><br><span class="line"></span><br><span class="line">Poco::Util::JSONConfiguration json;</span><br><span class="line">json.load(configFullPath);</span><br><span class="line">json.setInt(&quot;ConfigTest.item1&quot;, 102);</span><br><span class="line"></span><br><span class="line">std::ofstream ostr(configFullPath);</span><br><span class="line">json.save(ostr);</span><br></pre></td></tr></table></figure>


<h2 id="默认日志支持"><a href="#默认日志支持" class="headerlink" title="默认日志支持"></a>默认日志支持</h2><p>框架默认就实例化了一个名为”ApplicationStartup”的日志记录器，而且在初始化时就给根日志记录器绑定了一个控制台输出的Channel。因此，直接使用框架的提供的Logger实例和根日志记录器均能将相关信息输出到控制台。</p>
<p>另外，框架在初始化的是否添加了一个日志子系统。日志子系统会从框架的配置文件中读取application.logger配置项，进而构造出整个日志系统实例。通过配置文件就能定义好项目的全部日志记录配置，比如格式、输出位置等，LoggingConfigurator类就是完成从配置项你构造出日志实例的工作。</p>
<p>以下是一个项目的实例.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">logging.formatters.f1.class &#x3D; PatternFormatter  </span><br><span class="line">logging.formatters.f1.pattern  &#x3D; %s: [%p] %t </span><br><span class="line">logging.formatters.f1.times  &#x3D; UTC</span><br><span class="line"># f1是一个格式器名字，class表明格式器对应的类是Patternformatter, 其它的属性都是class表明的类所支持的，会在构建Formatter格式器时自动构建。</span><br><span class="line"></span><br><span class="line"># External Formatter </span><br><span class="line">logging.channels.c1.class &#x3D; ConsoleChannel </span><br><span class="line">logging.channels.c1.formatter  &#x3D; f1</span><br><span class="line"></span><br><span class="line"># Inline Formatter </span><br><span class="line">logging.channels.c2.class &#x3D; FileChannel </span><br><span class="line">logging.channels.c2.path  &#x3D; $&#123;system.tempDir&#125;&#x2F;sample.log </span><br><span class="line">logging.channels.c2.formatter.class &#x3D; PatternFormatter  </span><br><span class="line">logging.channels.c2.formatter.pattern &#x3D; %Y-%m-%d %H:%M:%S %s: [%p] %t</span><br><span class="line">c2是一个通道的名字，class表明通道类别，其它的配置项表明是通道的属性。</span><br><span class="line">有formatter属性存在话，本通道会自动的被包裹在FormattingChannel中，且使用class定义的格式器。</span><br><span class="line"></span><br><span class="line"># Inline PatternFormatter </span><br><span class="line">logging.channels.c3.class &#x3D; ConsoleChannel </span><br><span class="line">logging.channels.c3.pattern &#x3D; %s: [%p] %t </span><br><span class="line">有pattern存在的话，会自动的使用FormattingChannel和PatternFormatter</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># External Channel </span><br><span class="line">logging.loggers.root.channel &#x3D; c1 </span><br><span class="line">logging.loggers.root.level &#x3D; warning</span><br><span class="line"></span><br><span class="line"># Inline Channel with PatternFormatter </span><br><span class="line">logging.loggers.l1.name &#x3D; logger1 </span><br><span class="line">logging.loggers.l1.channel.class &#x3D; ConsoleChannel  </span><br><span class="line">logging.loggers.l1.channel.pattern &#x3D; %s: [%p] %t </span><br><span class="line">logging.loggers.l1.level &#x3D; information</span><br><span class="line"></span><br><span class="line"># SplitterChannel </span><br><span class="line">logging.channels.splitter.class &#x3D; SplitterChannel </span><br><span class="line">logging.channels.splitter.channels &#x3D; l1,l2 </span><br><span class="line">logging.loggers.l2.name &#x3D; logger2 </span><br><span class="line">logging.loggers.l2.channel &#x3D; splitter</span><br></pre></td></tr></table></figure>

<p>日志实例的初始化是在Application的构造函数中进行的，甚至早于前面的loadConfiguration过程，但是比设置系统变量要晚，一次在配置文件中可以使用system.tempDir这样的值，但是无法使用application.dir这样的值。</p>
<h2 id="命令行处理"><a href="#命令行处理" class="headerlink" title="命令行处理"></a>命令行处理</h2><h2 id="框架的初始化顺序"><a href="#框架的初始化顺序" class="headerlink" title="框架的初始化顺序"></a>框架的初始化顺序</h2><ol>
<li>读取SystemConfiguration，设置system.xxx配置项。</li>
<li>设置根记录器的Channel为控制台。</li>
<li>设置application.xxx配置。</li>
<li>处理命令行参数（init函数）</li>
<li>自定义Application的initialize接口</li>
<li>初始化日志子系统，从配置文件中创建日志记录器实例（run函数），前面虽然能通过控制显示日志，但是是这里才完善整个系统的日志。</li>
<li>main函数</li>
</ol>
]]></content>
      <categories>
        <category>C++</category>
        <category>Poco</category>
      </categories>
      <tags>
        <tag>Poco</tag>
      </tags>
  </entry>
  <entry>
    <title>编译Poco库</title>
    <url>/2018/05/24/cpp/Poco/%E7%BC%96%E8%AF%91Poco%E5%BA%93/</url>
    <content><![CDATA[<p>现阶段工作相关开发，主要涉及到Windows/Linux/ARM-Linux/WINCE几个平台。深刻感受到涉及到这几个平台的通用程序总是要在 文件管理/线程/网络 这几个方面要多花掉很多时间。自己处理的跨平台代码总是感觉不满意，也担心通用性问题。最终还是决定寻找一个好用的跨平台基础库，最终发现了Poco C++ Library库，决定之后的开发中，能用的话就尽量使用上Poco库。</p>
<a id="more"></a>

<h1 id="开发环境准备"><a href="#开发环境准备" class="headerlink" title="开发环境准备"></a>开发环境准备</h1><p>几个平台的开发主要用到的开发工具有：Visual Stdio 2008/2013、Qt 、Mingw32、Ubuntu。其中Visual Studio主要用来开发WINCE程序，Qt用来开发Windows/Ubuntu/arm-linux上的界面程序。Mingw则是Windows上需要用到的一个编译工具，下面就记录下具体的编译过程。</p>
<h1 id="WINCE平台Poco库编译"><a href="#WINCE平台Poco库编译" class="headerlink" title="WINCE平台Poco库编译"></a>WINCE平台Poco库编译</h1><p>VS系列的编译，在源码目录中已经提供了VS的各个版本的工程文件，也包括VS2008编译Wince6.0平台的工程，但是源码目录中的WINCE SDK是适用于<code>Digi JumpStart (ARMV4I)</code>平台的，不一定适合我们自己的平台。需要我们打开源码目录中的各个wince工程的sln、vcproj文件，把所有的<code>Digi JumpStart (ARMV4I)</code>替换成我们的平台,比如是<code>EPCS 9000(ARMV4I)</code>。</p>
<p>替换完成后，打开windows的命令行，进入到源码目录后，运行源码根目录的<code>build_CE_vs90.cmd</code>即可。若是编译遇到问题，只需要进入到出问题的模块的目录中，打开sln工程文件，手动更改编译参数，手动解决问题就行。编译过程中预计会遇到如下的几个问题，记录下：</p>
<ol>
<li>找不到某些头文件的问题。在Foundation目录下有wcelibcex-1.0目录，首先编译这个库，生成静态lib文件。缺失的头文件，只需要修改为引用wcelibcex库即可。</li>
<li>部分文件确实编译有问题，在Foundataion的时候，WindowsConsoleChannel.cpp 这个文件无法编译，需要去掉。</li>
<li>源码中Encodings模块DoubleByteEncoding.cpp文件中有个关于比较函数对象的代码是有问题，在VS2008中编译会失败(但是在VS2013是没问题的),需要手动处理下。</li>
<li>Poco::Path::current 函数在WINCE平台中固定返回”/“，可以修改代码返回正确的路径。</li>
</ol>
<p>解决这几个问题之后，编译就基本上OK了。在使用的时候有如下几个地方需要注意下：</p>
<ol>
<li>WINCE不支持环境变量，有关于环境变量的函数不要使用。</li>
<li>在Windows CE的读写器锁实现中，写入器总是优先于读取器。</li>
<li>Windwos CE中不支持对进程通过管道来重定向读和写。</li>
<li>日志框架中关于写日志到控制台的功能不能使用。</li>
<li>使用Poco库的项目必须打开RTTI选项，在C/C++ -&gt; Lanuage 选项中。</li>
</ol>
<h1 id="Windows-MSVC-环境编译"><a href="#Windows-MSVC-环境编译" class="headerlink" title="Windows MSVC 环境编译"></a>Windows MSVC 环境编译</h1><p>编译MSVC开发环境的Poco库很简单，直接在命令行中运行<code>Build_vs120.cmd</code>即可，应该不会失败的。</p>
<h1 id="Ubuntu-Arm-linux-编译"><a href="#Ubuntu-Arm-linux-编译" class="headerlink" title="Ubuntu/Arm-linux 编译"></a>Ubuntu/Arm-linux 编译</h1><p>Linux下编译工具常用2步，先<code>./configure</code>,在<code>make &amp;&amp; make install</code>。编译Poco也不例外，编译arm-linux平台使用如下命令:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;configure --config&#x3D;ARM-Linux --static --shared --minimal --no-tests --no-samples</span><br></pre></td></tr></table></figure>
<p>编译Ubuntu平台库使用如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;configure --static --shared --minimal --no-tests --no-samples</span><br></pre></td></tr></table></figure>

<h1 id="Windows-Mingw-环境编译"><a href="#Windows-Mingw-环境编译" class="headerlink" title="Windows Mingw 环境编译"></a>Windows Mingw 环境编译</h1><h2 id="编译环境准备"><a href="#编译环境准备" class="headerlink" title="编译环境准备"></a>编译环境准备</h2><p>mingw作为Windows上的编译工具链，可以用来编译生成windows上运行的程序。Qt中使用mingw作为编译中，我觉得是好过MSVC的。Mingw作为一个编译工具，长久以来并没有专门的配套的开发IDE，通常被配置在eclipse/code block/qt等IDE中。Poco源码并没有提供这些IDE的工程文件，因此也不能使用这些ide来编译（太麻烦了）.</p>
<p>在windows上有多个工具用来模拟linux的环境，它们提供了一些列window版本的linux开发工具，也在它们提供的shell中运行linux命令，甚至能跑linux程序。其中最有名的是<code>cygwin</code>和<code>msys2</code>。这里我使用的是<code>msys2</code>，因为它比较简单，容易安装。在官网下载安装文件后，直接安装即可。然后再其shell中使用命令再安装make等工具，编译工具则可以直接将安装qt时使用mingw文件拷贝到安装目录下的特定文件。</p>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>编译前还需要修改下配置文件，打开build/config/MinGW文件，</p>
<ul>
<li>在CFLAGS 变量中添加 <code>-std=c99</code>  解决pdjson库编译的问题。</li>
<li>将STRIP = strip 改为 STRIP =   , 不对生成的dll进行去符号的过程，这一过程旨在减少dll的大小。</li>
<li>将LINKMODE = SHARED    默认是STATIC，只有改成SHARED才能生成动态库。</li>
</ul>
<p>更改完成后打开msys shell进入到Poco源码目录后，使用如下命令后，再使用make即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;configure --config&#x3D;MinGW --static --shared --minimal --no-tests --no-samples</span><br></pre></td></tr></table></figure>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="http://blog.littlestory.cc/2017/07/31/pocolibanalyzation/" target="_blank" rel="noopener">Poco C++ 分析</a></li>
<li><a href="https://pocoproject.org/docs/" target="_blank" rel="noopener">Poco官网</a></li>
</ol>
]]></content>
      <categories>
        <category>C++</category>
        <category>Poco</category>
      </categories>
      <tags>
        <tag>Poco</tag>
      </tags>
  </entry>
</search>
